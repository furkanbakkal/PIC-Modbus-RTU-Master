CCS PCH C Compiler, Version 5.101, 61971               22-Kas-22 00:01

               Filename:   C:\Users\furka\OneDrive\Masaüstü\modbus-master\main.lst

               ROM used:   2906 bytes (9%)
                           Largest free fragment is 29858
               RAM used:   118 (8%) at main() level
                           141 (9%) worst case
               Stack used: 7 locations (4 in main + 3 for interrupts)
               Stack size: 31

*
0000:  GOTO   0A54
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.0
0056:  GOTO   0060
005A:  BTFSC  F9E.0
005C:  GOTO   02EE
0060:  BTFSS  F9D.5
0062:  GOTO   006C
0066:  BTFSC  F9E.5
0068:  GOTO   0392
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... // TTL to USB : https://www.robolinkmarket.com/usb-rs485-donusturucu-modul
.................... // RS485 to TTL : https://www.robolinkmarket.com/rs485-ttl-seri-donusturucu-karti
.................... // Source: https://github.com/furkanbakkal
.................... 
.................... //DE and RE pins shorted ->D2
.................... //DI -> TX
.................... //RO -> RX
.................... 
.................... //A->A  
.................... //B->B
.................... 
.................... /*Supported functions:
.................... 3 : Read holding register
.................... 6 : Write single register
.................... 15: Write multiple registers
.................... */
.................... 
.................... /* LCD Pins
.................... LCD_DB4   PIN_B4
.................... LCD_DB5   PIN_B5
.................... LCD_DB6   PIN_B6
.................... LCD_DB7   PIN_B7
.................... LCD_RS    PIN_B3
.................... LCD_RW    PIN_B2
.................... LCD_E     PIN_B1
.................... */
.................... 
.................... #include <main.h>
.................... #include <18F4520.h>
.................... //////////// Standard Header file for the PIC18F4520 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
*
02F0:  BCF    F9E.0
02F2:  GOTO   006C
.................... #device PIC18F4520
*
00BA:  CLRF   FF7
00BC:  ADDLW  CA
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  RETURN 0
00CA:  DATA 00,C1
00CC:  DATA 81,40
00CE:  DATA 01,C0
00D0:  DATA 80,41
00D2:  DATA 01,C0
00D4:  DATA 80,41
00D6:  DATA 00,C1
00D8:  DATA 81,40
00DA:  DATA 01,C0
00DC:  DATA 80,41
00DE:  DATA 00,C1
00E0:  DATA 81,40
00E2:  DATA 00,C1
00E4:  DATA 81,40
00E6:  DATA 01,C0
00E8:  DATA 80,41
00EA:  DATA 01,C0
00EC:  DATA 80,41
00EE:  DATA 00,C1
00F0:  DATA 81,40
00F2:  DATA 00,C1
00F4:  DATA 81,40
00F6:  DATA 01,C0
00F8:  DATA 80,41
00FA:  DATA 00,C1
00FC:  DATA 81,40
00FE:  DATA 01,C0
0100:  DATA 80,41
0102:  DATA 01,C0
0104:  DATA 80,41
0106:  DATA 00,C1
0108:  DATA 81,40
010A:  DATA 01,C0
010C:  DATA 80,41
010E:  DATA 00,C1
0110:  DATA 81,40
0112:  DATA 00,C1
0114:  DATA 81,40
0116:  DATA 01,C0
0118:  DATA 80,41
011A:  DATA 00,C1
011C:  DATA 81,40
011E:  DATA 01,C0
0120:  DATA 80,41
0122:  DATA 01,C0
0124:  DATA 80,41
0126:  DATA 00,C1
0128:  DATA 81,40
012A:  DATA 00,C1
012C:  DATA 81,40
012E:  DATA 01,C0
0130:  DATA 80,41
0132:  DATA 01,C0
0134:  DATA 80,41
0136:  DATA 00,C1
0138:  DATA 81,40
013A:  DATA 01,C0
013C:  DATA 80,41
013E:  DATA 00,C1
0140:  DATA 81,40
0142:  DATA 00,C1
0144:  DATA 81,40
0146:  DATA 01,C0
0148:  DATA 80,41
014A:  DATA 01,C0
014C:  DATA 80,41
014E:  DATA 00,C1
0150:  DATA 81,40
0152:  DATA 00,C1
0154:  DATA 81,40
0156:  DATA 01,C0
0158:  DATA 80,41
015A:  DATA 00,C1
015C:  DATA 81,40
015E:  DATA 01,C0
0160:  DATA 80,41
0162:  DATA 01,C0
0164:  DATA 80,41
0166:  DATA 00,C1
0168:  DATA 81,40
016A:  DATA 00,C1
016C:  DATA 81,40
016E:  DATA 01,C0
0170:  DATA 80,41
0172:  DATA 01,C0
0174:  DATA 80,41
0176:  DATA 00,C1
0178:  DATA 81,40
017A:  DATA 01,C0
017C:  DATA 80,41
017E:  DATA 00,C1
0180:  DATA 81,40
0182:  DATA 00,C1
0184:  DATA 81,40
0186:  DATA 01,C0
0188:  DATA 80,41
018A:  DATA 00,C1
018C:  DATA 81,40
018E:  DATA 01,C0
0190:  DATA 80,41
0192:  DATA 01,C0
0194:  DATA 80,41
0196:  DATA 00,C1
0198:  DATA 81,40
019A:  DATA 01,C0
019C:  DATA 80,41
019E:  DATA 00,C1
01A0:  DATA 81,40
01A2:  DATA 00,C1
01A4:  DATA 81,40
01A6:  DATA 01,C0
01A8:  DATA 80,41
01AA:  DATA 01,C0
01AC:  DATA 80,41
01AE:  DATA 00,C1
01B0:  DATA 81,40
01B2:  DATA 00,C1
01B4:  DATA 81,40
01B6:  DATA 01,C0
01B8:  DATA 80,41
01BA:  DATA 00,C1
01BC:  DATA 81,40
01BE:  DATA 01,C0
01C0:  DATA 80,41
01C2:  DATA 01,C0
01C4:  DATA 80,41
01C6:  DATA 00,C1
01C8:  DATA 81,40
01CA:  CLRF   FF7
01CC:  ADDLW  DA
01CE:  MOVWF  FF6
01D0:  MOVLW  01
01D2:  ADDWFC FF7,F
01D4:  TBLRD*+
01D6:  MOVF   FF5,W
01D8:  RETURN 0
01DA:  DATA 00,C0
01DC:  DATA C1,01
01DE:  DATA C3,03
01E0:  DATA 02,C2
01E2:  DATA C6,06
01E4:  DATA 07,C7
01E6:  DATA 05,C5
01E8:  DATA C4,04
01EA:  DATA CC,0C
01EC:  DATA 0D,CD
01EE:  DATA 0F,CF
01F0:  DATA CE,0E
01F2:  DATA 0A,CA
01F4:  DATA CB,0B
01F6:  DATA C9,09
01F8:  DATA 08,C8
01FA:  DATA D8,18
01FC:  DATA 19,D9
01FE:  DATA 1B,DB
0200:  DATA DA,1A
0202:  DATA 1E,DE
0204:  DATA DF,1F
0206:  DATA DD,1D
0208:  DATA 1C,DC
020A:  DATA 14,D4
020C:  DATA D5,15
020E:  DATA D7,17
0210:  DATA 16,D6
0212:  DATA D2,12
0214:  DATA 13,D3
0216:  DATA 11,D1
0218:  DATA D0,10
021A:  DATA F0,30
021C:  DATA 31,F1
021E:  DATA 33,F3
0220:  DATA F2,32
0222:  DATA 36,F6
0224:  DATA F7,37
0226:  DATA F5,35
0228:  DATA 34,F4
022A:  DATA 3C,FC
022C:  DATA FD,3D
022E:  DATA FF,3F
0230:  DATA 3E,FE
0232:  DATA FA,3A
0234:  DATA 3B,FB
0236:  DATA 39,F9
0238:  DATA F8,38
023A:  DATA 28,E8
023C:  DATA E9,29
023E:  DATA EB,2B
0240:  DATA 2A,EA
0242:  DATA EE,2E
0244:  DATA 2F,EF
0246:  DATA 2D,ED
0248:  DATA EC,2C
024A:  DATA E4,24
024C:  DATA 25,E5
024E:  DATA 27,E7
0250:  DATA E6,26
0252:  DATA 22,E2
0254:  DATA E3,23
0256:  DATA E1,21
0258:  DATA 20,E0
025A:  DATA A0,60
025C:  DATA 61,A1
025E:  DATA 63,A3
0260:  DATA A2,62
0262:  DATA 66,A6
0264:  DATA A7,67
0266:  DATA A5,65
0268:  DATA 64,A4
026A:  DATA 6C,AC
026C:  DATA AD,6D
026E:  DATA AF,6F
0270:  DATA 6E,AE
0272:  DATA AA,6A
0274:  DATA 6B,AB
0276:  DATA 69,A9
0278:  DATA A8,68
027A:  DATA 78,B8
027C:  DATA B9,79
027E:  DATA BB,7B
0280:  DATA 7A,BA
0282:  DATA BE,7E
0284:  DATA 7F,BF
0286:  DATA 7D,BD
0288:  DATA BC,7C
028A:  DATA B4,74
028C:  DATA 75,B5
028E:  DATA 77,B7
0290:  DATA B6,76
0292:  DATA 72,B2
0294:  DATA B3,73
0296:  DATA B1,71
0298:  DATA 70,B0
029A:  DATA 50,90
029C:  DATA 91,51
029E:  DATA 93,53
02A0:  DATA 52,92
02A2:  DATA 96,56
02A4:  DATA 57,97
02A6:  DATA 55,95
02A8:  DATA 94,54
02AA:  DATA 9C,5C
02AC:  DATA 5D,9D
02AE:  DATA 5F,9F
02B0:  DATA 9E,5E
02B2:  DATA 5A,9A
02B4:  DATA 9B,5B
02B6:  DATA 99,59
02B8:  DATA 58,98
02BA:  DATA 88,48
02BC:  DATA 49,89
02BE:  DATA 4B,8B
02C0:  DATA 8A,4A
02C2:  DATA 4E,8E
02C4:  DATA 8F,4F
02C6:  DATA 8D,4D
02C8:  DATA 4C,8C
02CA:  DATA 44,84
02CC:  DATA 85,45
02CE:  DATA 87,47
02D0:  DATA 46,86
02D2:  DATA 82,42
02D4:  DATA 43,83
02D6:  DATA 41,81
02D8:  DATA 80,40
02DA:  CLRF   FF7
02DC:  ADDLW  EA
02DE:  MOVWF  FF6
02E0:  MOVLW  02
02E2:  ADDWFC FF7,F
02E4:  TBLRD*+
02E6:  MOVF   FF5,W
02E8:  RETURN 0
02EA:  DATA 28,0C
02EC:  DATA 01,06
02EE:  INCF   5F,F
*
03FE:  DATA 53,79
0400:  DATA 73,74
0402:  DATA 65,6D
0404:  DATA 20,53
0406:  DATA 74,61
0408:  DATA 72,74
040A:  DATA 65,64
040C:  DATA 21,00
040E:  DATA 25,6C
0410:  DATA 75,20
0412:  DATA 20,20
0414:  DATA 20,20
0416:  DATA 20,00
*
061C:  TBLRD*+
061E:  MOVF   FF5,F
0620:  BZ    063A
0622:  MOVFF  FF6,74
0626:  MOVFF  FF7,75
062A:  MOVFF  FF5,7F
062E:  RCALL  05D4
0630:  MOVFF  74,FF6
0634:  MOVFF  75,FF7
0638:  BRA    061C
063A:  GOTO   0AD0 (RETURN)
*
0978:  MOVFF  FEA,7E
097C:  MOVFF  FE9,7D
0980:  SWAPF  77,W
0982:  IORLW  F0
0984:  MOVWF  79
0986:  ADDWF  79,F
0988:  ADDLW  E2
098A:  MOVWF  7A
098C:  ADDLW  32
098E:  MOVWF  7C
0990:  MOVF   77,W
0992:  ANDLW  0F
0994:  ADDWF  7A,F
0996:  ADDWF  7A,F
0998:  ADDWF  7C,F
099A:  ADDLW  E9
099C:  MOVWF  7B
099E:  ADDWF  7B,F
09A0:  ADDWF  7B,F
09A2:  SWAPF  76,W
09A4:  ANDLW  0F
09A6:  ADDWF  7B,F
09A8:  ADDWF  7C,F
09AA:  RLCF   7B,F
09AC:  RLCF   7C,F
09AE:  COMF   7C,F
09B0:  RLCF   7C,F
09B2:  MOVF   76,W
09B4:  ANDLW  0F
09B6:  ADDWF  7C,F
09B8:  RLCF   79,F
09BA:  MOVLW  07
09BC:  MOVWF  78
09BE:  MOVLW  0A
09C0:  DECF   7B,F
09C2:  ADDWF  7C,F
09C4:  BNC   09C0
09C6:  DECF   7A,F
09C8:  ADDWF  7B,F
09CA:  BNC   09C6
09CC:  DECF   79,F
09CE:  ADDWF  7A,F
09D0:  BNC   09CC
09D2:  DECF   78,F
09D4:  ADDWF  79,F
09D6:  BNC   09D2
09D8:  CLRF   FEA
09DA:  MOVLW  78
09DC:  MOVWF  FE9
09DE:  MOVLW  07
09E0:  ANDWF  7D,W
09E2:  BCF    7D.6
09E4:  ADDWF  FE9,F
09E6:  MOVLW  00
09E8:  ADDWFC FEA,F
09EA:  MOVF   FE9,W
09EC:  SUBLW  7C
09EE:  BNZ   09F6
09F0:  MOVF   FEA,F
09F2:  BNZ   09F6
09F4:  BSF    7D.6
09F6:  MOVF   FEF,W
09F8:  MOVWF  00
09FA:  BNZ   0A0C
09FC:  BTFSC  7D.6
09FE:  BRA    0A0C
0A00:  BTFSC  7D.4
0A02:  BRA    0A2A
0A04:  BTFSC  7D.3
0A06:  BRA    0A0C
0A08:  MOVLW  20
0A0A:  BRA    0A12
0A0C:  BSF    7D.3
0A0E:  BCF    7D.4
0A10:  MOVLW  30
0A12:  ADDWF  00,F
0A14:  MOVFF  FEA,77
0A18:  MOVFF  FE9,76
0A1C:  MOVFF  00,7F
0A20:  RCALL  05D4
0A22:  MOVFF  77,FEA
0A26:  MOVFF  76,FE9
0A2A:  MOVF   FEE,W
0A2C:  BTFSS  7D.6
0A2E:  BRA    09EA
0A30:  GOTO   0B26 (RETURN)
0A34:  TBLRD*+
0A36:  MOVFF  FF6,77
0A3A:  MOVFF  FF7,78
0A3E:  MOVFF  FF5,7F
0A42:  RCALL  05D4
0A44:  MOVFF  77,FF6
0A48:  MOVFF  78,FF7
0A4C:  DECFSZ 76,F
0A4E:  BRA    0A34
0A50:  GOTO   0B34 (RETURN)
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... 
.................... #FUSES NOWDT                 	//No Watch Dog Timer
.................... 
.................... #use delay(internal=8MHz)
*
0442:  CLRF   FEA
0444:  MOVLW  80
0446:  MOVWF  FE9
0448:  MOVF   FEF,W
044A:  BZ    0466
044C:  MOVLW  02
044E:  MOVWF  01
0450:  CLRF   00
0452:  DECFSZ 00,F
0454:  BRA    0452
0456:  DECFSZ 01,F
0458:  BRA    0450
045A:  MOVLW  97
045C:  MOVWF  00
045E:  DECFSZ 00,F
0460:  BRA    045E
0462:  DECFSZ FEF,F
0464:  BRA    044C
0466:  RETURN 0
.................... 
.................... 
.................... 
.................... #define MODBUS_BUS SERIAL
.................... #define MODBUS_TYPE MODBUS_TYPE_MASTER //PIC is master, PC is slave
.................... #define MODBUS_SERIAL_TYPE MODBUS_RTU     //use MODBUS_ASCII for ASCII mode
.................... #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA //Default TX RX pins 
.................... #define MODBUS_SERIAL_RX_ENABLE PIN_D2   // Controls RE pin for RS485
.................... #define MODBUS_SERIAL_BAUD 9600 //baudrate
.................... #define MODBUS_SLAVE_ADDRESS 0x05 //slave adress (default 5)
.................... 
.................... #define LED PIN_C4 //output pin (if address-reg 0 is "1" this pin will be ON, if address-reg 0 is "0" this pin will be OFF)
.................... 
.................... #include"modbus.c"
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                     modbus.c                                     ////
.................... ////                                                                                  ////
.................... ////           MODBUS protocol driver for serial and TCP/IP communications.           ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... ////  How to Use:                                                                     ////
.................... ////                                                                                  ////
.................... ////  Include just this file, modbus.c, in your main program. Before including this   ////
.................... ////  file define the constants below for your needs.                                 ////
.................... ////                                                                                  ////
.................... //// DEFINES:                                                                         ////
.................... ////  MODBUS_PROTOCOL               MODBUS_PROTOCOL_SERIAL or MODBUS_PROTOCOL_TCPIP   ////
.................... ////                                                                                  ////
.................... //// SERIAL DEFINES:                                                                  ////
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           ////
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              ////
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2,   ////
.................... ////                                   MODBUS_INT_RDA3,MODBUS_INT_RDA4)               ////
.................... ////  MODBUS_SERIAL_TYPE            MODBUS_RTU or MODBUS_ASCII                        ////
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        ////
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      ////
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     ////
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           ////
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       ////
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        ////
.................... ////                                                                                  ////
.................... //// TCP/IP DEFINES:                                                                  ////
.................... ////  MODBUS_TYPE                   MODBYS_TYPE_CLIENT or MODBUS_TYPE_SERVER          ////
.................... ////  MODBUS_SERVER_LISTEN_PORT     Port server/client listens/sends messages to      ////
.................... ////                                   (default 502)                                  ////
.................... ////  MODBUS_LISTEN_SOCKETS         Number of sockets server listens to (default 1)   ////
.................... ////  MODBUS_BUFFER_SIZE            Size of receive and transmit buffers (default 64) ////
.................... ////  MODBUS_SERVER_TIMEOUT         Time is seconds client will wait for response     ////
.................... ////                                   from server before setting TIMEOUT exception   ////
.................... ////                                   (default 5)                                    ////
.................... ////  MODBUS_SERVER_ADDR_0          TCP/IP address client connects to MSB             ////
.................... ////  MODBUS_SERVER_ADDR_1          TCP/IP address client connects to                 ////
.................... ////  MODBUS_SERVER_ADDR_2          TCP/IP address client connects to                 ////
.................... ////  MODBUS_SERVER_ADDR_3          TCP/IP address client connects to LSB             ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// Revision history:                                                                ////
.................... ////  May 8, 2009       Made PCD Compatible                                           ////
.................... ////  August 21, 2009   Added Modbus ASCII protocol                                   ////
.................... ////  May 20, 2010      Changed variables to unsigned for PCD and if #device ANSI is  ////
.................... ////                    used for PCM or PCH. Fixed bug when multiple UARTS are used   ////
.................... ////                    on PIC.                                                       ////
.................... ////  July 20, 2011     Seperated modbus.c into 7 files, including this one. The code ////
.................... ////                    was seperated into header and c files for the Physical and    ////
.................... ////                    Application layers, and RTU code and ASCII code.              ////
.................... ////  November 1, 2011  Added Modbus TCP/IP protocol.                                 ////
.................... ////  Janurary 9, 2013  Added support for Even and Odd Parity for RTU and ASCII       ////
.................... ////                    modes.                                                        ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #include <modbus.h>
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                     modbus.h                                     ////
.................... ////                                                                                  ////
.................... ////           MODBUS protocol driver for serial and TCP/IP communications.           ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// DEFINES:                                                                         ////
.................... ////  MODBUS_PROTOCOL               MODBUS_PROTOCOL_SERIAL or MODBUS_PROTOCOL_TCPIP   ////
.................... ////                                                                                  ////
.................... //// SERIAL DEFINES:                                                                  ////
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           ////
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              ////
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2,   ////
.................... ////                                   MODBUS_INT_RDA3,MODBUS_INT_RDA4)               ////
.................... ////  MODBUS_SERIAL_TYPE            MODBUS_RTU or MODBUS_ASCII                        ////
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        ////
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      ////
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     ////
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           ////
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       ////
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        ////
.................... ////                                                                                  ////
.................... //// TCP/IP DEFINES:                                                                  ////
.................... ////  MODBUS_TYPE                   MODBYS_TYPE_CLIENT or MODBUS_TYPE_SERVER          ////
.................... ////  MODBUS_SERVER_LISTEN_PORT     Port server/client listens/sends messages to      ////
.................... ////                                   (default 502)                                  ////
.................... ////  MODBUS_LISTEN_SOCKETS         Number of sockets server listens to (default 1)   ////
.................... ////  MODBUS_BUFFER_SIZE            Size of receive and transmit buffers (default 64) ////
.................... ////  MODBUS_SERVER_TIMEOUT         Time is seconds client will wait for response     ////
.................... ////                                   from server before setting TIMEOUT exception   ////
.................... ////                                   (default 5)                                    ////
.................... ////  MODBUS_SERVER_ADDR_0          TCP/IP address client connects to MSB             ////
.................... ////  MODBUS_SERVER_ADDR_1          TCP/IP address client connects to                 ////
.................... ////  MODBUS_SERVER_ADDR_2          TCP/IP address client connects to                 ////
.................... ////  MODBUS_SERVER_ADDR_3          TCP/IP address client connects to LSB             ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// Revision history:                                                                ////
.................... ////  May 8, 2009       Made PCD Compatible                                           ////
.................... ////  August 21, 2009   Added Modbus ASCII protocol                                   ////
.................... ////  May 20, 2010      Changed variables to unsigned for PCD and if #device ANSI is  ////
.................... ////                    used for PCM or PCH. Fixed bug when multiple UARTS are used   ////
.................... ////                    on PIC.                                                       ////
.................... ////  July 20, 2011     Seperated modbus.c into 7 files, including this one. The code ////
.................... ////                    was seperated into header and c files for the Physical and    ////
.................... ////                    Application layers, and RTU code and ASCII code.              ////
.................... ////  November 1, 2011  Added Modbus TCP/IP protocol.                                 ////
.................... ////  Janurary 9, 2013  Added support for Even and Odd Parity for RTU and ASCII       ////
.................... ////                    modes.                                                        ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2010 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MODBUS_H
.................... #define MODBUS_H
.................... 
.................... /*Some defines so we can use identifiers to set things up*/
.................... #define MODBUS_PROTOCOL_SERIAL 0
.................... #define MODBUS_PROTOCOL_TCPIP  100
.................... #define MODBUS_TYPE_MASTER 99999
.................... #define MODBUS_TYPE_SLAVE  88888
.................... #define MODBUS_TYPE_CLIENT 20
.................... #define MODBUS_TYPE_SERVER 21
.................... #define MODBUS_INT_RDA     77777
.................... #define MODBUS_INT_RDA2    66666
.................... #define MODBUS_INT_RDA3    44444
.................... #define MODBUS_INT_RDA4    33333
.................... #define MODBUS_INT_RDA5    22222
.................... #define MODBUS_INT_RDA6    11111
.................... #define MODBUS_INT_EXT     55555
.................... #define MODBUS_RTU         1
.................... #define MODBUS_ASCII       2
.................... #define MODBUS_TIMER_NOISR 13
.................... #define MODBUS_TIMER_ISR   12
.................... #define MODBUS_TIMER_T1    14
.................... #define MODBUS_TIMER_T2    15
.................... 
.................... #ifndef MODBUS_PROTOCOL
....................  #define MODBUS_PROTOCOL MODBUS_PROTOCOL_SERIAL
.................... #endif
.................... 
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_SERIAL)
....................  #ifndef MODBUS_TYPE
....................   #define MODBUS_TYPE MODBUS_TYPE_MASTER
....................  #endif
.................... 
....................  #ifndef MODBUS_SERIAL_TYPE
....................   #define MODBUS_SERIAL_TYPE MODBUS_RTU
....................  #endif
.................... 
....................  #ifndef MODBUS_SERIAL_INT_SOURCE
....................   #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA   // Select between external interrupt
....................  #endif                                             // or asynchronous serial interrupt
.................... 
....................  #ifndef MODBUS_SERIAL_BAUD
....................   #define MODBUS_SERIAL_BAUD 9600
....................  #endif
.................... 
....................  #ifndef MODBUS_SERIAL_RX_PIN
....................   #define MODBUS_SERIAL_RX_PIN       PIN_C7   // Data receive pin
....................  #endif
.................... 
....................  #ifndef MODBUS_SERIAL_TX_PIN
....................   #define MODBUS_SERIAL_TX_PIN       PIN_C6   // Data transmit pin
....................  #endif
.................... 
....................  #ifndef MODBUS_SERIAL_ENABLE_PIN
....................   #define MODBUS_SERIAL_ENABLE_PIN   0   // Controls DE pin.  RX low, TX high.
....................  #endif
.................... 
....................  #ifndef MODBUS_SERIAL_RX_ENABLE
....................   #define MODBUS_SERIAL_RX_ENABLE    0   // Controls RE pin.  Should keep low.
....................  #endif
.................... 
....................  #ifndef MODBUS_PARITY
....................   #define MODBUS_PARITY "EVEN"
....................  #endif
.................... 
....................  #ifndef MODBUS_SERIAL_TIMEOUT
....................   #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII)
....................    #define MODBUS_SERIAL_TIMEOUT    1000000
....................   #else
....................    #define MODBUS_SERIAL_TIMEOUT      10000     //in us
....................   #endif
....................  #endif
.................... 
....................  #ifndef MODBUS_SERIAL_RX_BUFFER_SIZE
....................   #define MODBUS_SERIAL_RX_BUFFER_SIZE  64      //size of send/rcv buffer
....................  #endif
.................... 
....................  #ifndef MODBUS_TIMER_UPDATE
....................   #define MODBUS_TIMER_UPDATE MODBUS_TIMER_ISR
....................  #endif
.................... 
....................  #ifndef MODBUS_TIMER_USED
....................   #define MODBUS_TIMER_USED MODBUS_TIMER_T1
....................  #endif
.................... 
.................... #else ///////////////////////// MODBUS TCP/IP PROTOCOL /////////////////////////
....................  #ifndef MODBUS_TYPE
....................   #define MODBUS_TYPE   MODBUS_TYPE_CLIENT
....................  #endif
.................... 
....................  #ifndef MODBUS_SERVER_LISTEN_PORT
....................   #define MODBUS_SERVER_LISTEN_PORT    502   //this is the default listen port for MODBUS TCP/IP protocol
....................  #endif
.................... 
....................  #if (MODBUS_TYPE == MODBUS_TYPE_SERVER)
....................   #ifndef MODBUS_LISTEN_SOCKETS
....................    #define MODBUS_LISTEN_SOCKETS     1
....................   #endif
....................  #endif
.................... 
....................  #ifndef MODBUS_BUFFER_SIZE
....................   #define MODBUS_BUFFER_SIZE   64
....................  #endif
.................... 
....................  #ifndef MODBUS_SERVER_TIMEOUT
....................   #define MODBUS_SERVER_TIMEOUT  5  //time in seconds that client will wait for server response before timeout
....................  #endif
.................... 
....................  #if (MODBUS_TYPE == MODBUS_TYPE_CLIENT)
....................   #ifndef MODBUS_SERVER_ADDR_0
....................    #define MODBUS_SERVER_ADDR_0  192
....................    #define MODBUS_SERVER_ADDR_1  168
....................    #define MODBUS_SERVER_ADDR_2  100
....................    #define MODBUS_SERVER_ADDR_3  140
....................   #endif
....................  #endif
.................... 
....................  #ifndef debug_printf
....................   #define debug_printf(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u)
....................  #endif
.................... 
.................... #endif
.................... 
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_TCPIP)
....................  #include <modbus_phy_layer_tcpip.h>
.................... #else
....................  #include <modbus_phy_layer.h>
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                modbus_phy_layer.h                                ////
.................... ////                                                                                  ////
.................... ////      Physical layer of the MODBUS protocol driver for serial communications.     ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// Revision history:                                                                ////
.................... ////                                                                                  ////
.................... ////  Sept 22, 2020       Updated TRMT bit variable for PIC18 devices with new UART   ////
.................... ////                      peripherial.  Added support for using UART5 and UART6 for   ////
.................... ////                      devices that have UART5 and UART6 peripherals.              ////
.................... ////                                                                                  ////
.................... ////  July 20, 2011       Seperated Physical Layer functions definitions into this    ////
.................... ////                      file from modbus.c                                          ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MODBUS_PHY_LAYER_H
.................... #define MODBUS_PHY_LAYER_H
.................... 
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER)
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU)
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\
.................... {\
....................    modbus_timeout_enabled = 0;\
....................    if(address)\
....................    {\
....................       while(!modbus_kbhit() && --modbus_serial_wait)\
....................          delay_us(1);\
....................       if(!modbus_serial_wait)\
....................          modbus_rx.error=TIMEOUT;\
....................    }\
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\
.................... }
.................... #else
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\
.................... {\
....................    if(address)\
....................    {\
....................       while(!modbus_kbhit() && --modbus_serial_wait)\
....................          delay_us(1);\
....................       if(!modbus_serial_wait)\
....................          modbus_rx.error=TIMEOUT;\
....................    }\
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\
.................... }
.................... #endif
.................... #endif
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT)
....................    #if defined(__PCD__)
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA)
....................          #word TXSTA=getenv("SFR:U1STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2)
....................          #word TXSTA=getenv("SFR:U2STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3)
....................          #word TXSTA=getenv("SFR:U3STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4)
....................          #word TXSTA=getenv("SFR:U4STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA5)
....................          #word TXSTA=getenv("SFR:U5STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA6)
....................          #word TXSTA=getenv("SFR:U6STA")
....................          #bit TRMT=TXSTA.8
....................       #endif
....................    #else
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA)
....................          #if getenv("sfr_valid:U1ERRIR")
....................             #byte TXSTA=getenv("SFR:U1ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA")
....................             #byte TXSTA=getenv("sfr:TXSTA")
....................             #bit TRMT=TXSTA.1
....................          #elif getenv("sfr_valid:TXSTA1")
....................             #byte TXSTA=getenv("sfr:TXSTA1")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX1STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2)
....................          #if getenv("sfr_valid:U2ERRIR")
....................             #byte TXSTA=getenv("SFR:U2ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA2")
....................             #byte TXSTA=getenv("sfr:TXSTA2")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX2STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3)
....................          #if getenv("sfr_valid:U3ERRIR")
....................             #byte TXSTA=getenv("SFR:U3ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA3")
....................             #byte TXSTA=getenv("sfr:TXSTA3")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX3STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4)
....................          #if getenv("sfr_valid:U4ERRIR")
....................             #byte TXSTA=getenv("SFR:U4ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA4")
....................             #byte TXSTA=getenv("sfr:TXSTA4")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX4STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA5)
....................          #if getenv("sfr_valid:U5ERRIR")
....................             #byte TXSTA=getenv("SFR:U5ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA5")
....................             #byte TXSTA=getenv("sfr:TXSTA5")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX5STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA6)
....................          #if getenv("sfr_valid:U6ERRIR")
....................             #byte TXSTA=getenv("SFR:U6ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA6")
....................             #byte TXSTA=getenv("sfr:TXSTA6")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX6STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................       #endif
....................    #endif
.................... #endif
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT)
.................... #define WAIT_FOR_HW_BUFFER()\
.................... {\
....................    while(!TRMT);\
.................... }
.................... #endif
.................... 
.................... int1 modbus_serial_new=0;
.................... 
.................... /********************************************************************
.................... These exceptions are defined in the MODBUS protocol.  These can be
.................... used by the slave to communicate problems with the transmission back
.................... to the master who can also use these to easily check the exceptions.
.................... The first exception is the only one that is not part of the protocol
.................... specification.  The TIMEOUT exception is returned when no slave
.................... responds to the master's request within the timeout period.
.................... ********************************************************************/
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11,
.................... TIMEOUT=12} exception;
.................... 
.................... /********************************************************************
.................... These functions are defined in the MODBUS protocol.  These can be
.................... used by the slave to check the incomming function.  See
.................... ex_modbus_slave.c for example usage.
.................... ********************************************************************/
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02,
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04,
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06,
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08,
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C,
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10,
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14,
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16,
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function;
.................... 
.................... /********************************************************************
.................... Our receive struct.  This is used when receiving data as a master or
.................... slave.  Once a message is sent to you with your address, you should
.................... begin processing that message.  Refer to ex_modbus_slave.c to see
.................... how to properly use this structure.
.................... ********************************************************************/
.................... struct
.................... {
....................    unsigned int8 address;
....................    unsigned int8 len;                       //number of bytes in the message received
....................    function func;                           //the function of the message received
....................    exception error;                         //error recieved, if any
....................    unsigned int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received
.................... } modbus_rx;
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////  For Custom Commands                                                             ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_start(address,func)                                          ////
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data ////
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_stop()                                                       ////
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_putc(unsigned int8 c)                                             ////
.................... ////    - Sends a character onto the serial line                                      ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // Purpose:    Send a message over the RS485 bus
.................... // Inputs:     1) The destination address
.................... //             2) The number of bytes of data to send
.................... //             3) A pointer to the data to send
.................... //             4) The length of the data
.................... // Outputs:    TRUE if successful
.................... //             FALSE if failed
.................... // Note:       Format:  source | destination | data-length | data | checksum
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func);
.................... 
.................... // Purpose:    Sends a message stop
.................... // Inputs:     none
.................... // Outputs:    None
.................... void modbus_serial_send_stop();
.................... 
.................... // Purpose:    Puts a character onto the serial line
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_serial_putc(unsigned int8 c);
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////  For Init                                                                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // Purpose:    Enable data reception
.................... // Inputs:     None
.................... // Outputs:    None
.................... void RCV_ON(void);
.................... 
.................... #endif //MODBUS_PHY_LAYER_H
.................... 
.................... #endif
.................... 
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_TCPIP)
....................  #include <modbus_app_layer_tcpip.h>
.................... #else
....................  #include <modbus_app_layer.h>
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                modbus_app_layer.h                                ////
.................... ////                                                                                  ////
.................... ////    Application layer of the MODBUS protocol driver for serial communications.    ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// Revision history:                                                                ////
.................... ////  July 20, 2011       Seperated App Layer functions into this file from modbus.c  ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MODBUS_APP_LAYER_H
.................... #define MODBUS_APP_LAYER_H
.................... 
.................... #include <modbus_phy_layer.h>
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                modbus_phy_layer.h                                ////
.................... ////                                                                                  ////
.................... ////      Physical layer of the MODBUS protocol driver for serial communications.     ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// Revision history:                                                                ////
.................... ////                                                                                  ////
.................... ////  Sept 22, 2020       Updated TRMT bit variable for PIC18 devices with new UART   ////
.................... ////                      peripherial.  Added support for using UART5 and UART6 for   ////
.................... ////                      devices that have UART5 and UART6 peripherals.              ////
.................... ////                                                                                  ////
.................... ////  July 20, 2011       Seperated Physical Layer functions definitions into this    ////
.................... ////                      file from modbus.c                                          ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MODBUS_PHY_LAYER_H
.................... #define MODBUS_PHY_LAYER_H
.................... 
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER)
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU)
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\
.................... {\
....................    modbus_timeout_enabled = 0;\
....................    if(address)\
....................    {\
....................       while(!modbus_kbhit() && --modbus_serial_wait)\
....................          delay_us(1);\
....................       if(!modbus_serial_wait)\
....................          modbus_rx.error=TIMEOUT;\
....................    }\
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\
.................... }
.................... #else
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\
.................... {\
....................    if(address)\
....................    {\
....................       while(!modbus_kbhit() && --modbus_serial_wait)\
....................          delay_us(1);\
....................       if(!modbus_serial_wait)\
....................          modbus_rx.error=TIMEOUT;\
....................    }\
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\
.................... }
.................... #endif
.................... #endif
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT)
....................    #if defined(__PCD__)
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA)
....................          #word TXSTA=getenv("SFR:U1STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2)
....................          #word TXSTA=getenv("SFR:U2STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3)
....................          #word TXSTA=getenv("SFR:U3STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4)
....................          #word TXSTA=getenv("SFR:U4STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA5)
....................          #word TXSTA=getenv("SFR:U5STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA6)
....................          #word TXSTA=getenv("SFR:U6STA")
....................          #bit TRMT=TXSTA.8
....................       #endif
....................    #else
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA)
....................          #if getenv("sfr_valid:U1ERRIR")
....................             #byte TXSTA=getenv("SFR:U1ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA")
....................             #byte TXSTA=getenv("sfr:TXSTA")
....................             #bit TRMT=TXSTA.1
....................          #elif getenv("sfr_valid:TXSTA1")
....................             #byte TXSTA=getenv("sfr:TXSTA1")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX1STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2)
....................          #if getenv("sfr_valid:U2ERRIR")
....................             #byte TXSTA=getenv("SFR:U2ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA2")
....................             #byte TXSTA=getenv("sfr:TXSTA2")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX2STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3)
....................          #if getenv("sfr_valid:U3ERRIR")
....................             #byte TXSTA=getenv("SFR:U3ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA3")
....................             #byte TXSTA=getenv("sfr:TXSTA3")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX3STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4)
....................          #if getenv("sfr_valid:U4ERRIR")
....................             #byte TXSTA=getenv("SFR:U4ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA4")
....................             #byte TXSTA=getenv("sfr:TXSTA4")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX4STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA5)
....................          #if getenv("sfr_valid:U5ERRIR")
....................             #byte TXSTA=getenv("SFR:U5ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA5")
....................             #byte TXSTA=getenv("sfr:TXSTA5")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX5STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA6)
....................          #if getenv("sfr_valid:U6ERRIR")
....................             #byte TXSTA=getenv("SFR:U6ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA6")
....................             #byte TXSTA=getenv("sfr:TXSTA6")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX6STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................       #endif
....................    #endif
.................... #endif
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT)
.................... #define WAIT_FOR_HW_BUFFER()\
.................... {\
....................    while(!TRMT);\
.................... }
.................... #endif
.................... 
.................... int1 modbus_serial_new=0;
.................... 
.................... /********************************************************************
.................... These exceptions are defined in the MODBUS protocol.  These can be
.................... used by the slave to communicate problems with the transmission back
.................... to the master who can also use these to easily check the exceptions.
.................... The first exception is the only one that is not part of the protocol
.................... specification.  The TIMEOUT exception is returned when no slave
.................... responds to the master's request within the timeout period.
.................... ********************************************************************/
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11,
.................... TIMEOUT=12} exception;
.................... 
.................... /********************************************************************
.................... These functions are defined in the MODBUS protocol.  These can be
.................... used by the slave to check the incomming function.  See
.................... ex_modbus_slave.c for example usage.
.................... ********************************************************************/
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02,
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04,
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06,
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08,
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C,
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10,
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14,
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16,
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function;
.................... 
.................... /********************************************************************
.................... Our receive struct.  This is used when receiving data as a master or
.................... slave.  Once a message is sent to you with your address, you should
.................... begin processing that message.  Refer to ex_modbus_slave.c to see
.................... how to properly use this structure.
.................... ********************************************************************/
.................... struct
.................... {
....................    unsigned int8 address;
....................    unsigned int8 len;                       //number of bytes in the message received
....................    function func;                           //the function of the message received
....................    exception error;                         //error recieved, if any
....................    unsigned int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received
.................... } modbus_rx;
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////  For Custom Commands                                                             ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_start(address,func)                                          ////
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data ////
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_stop()                                                       ////
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_putc(unsigned int8 c)                                             ////
.................... ////    - Sends a character onto the serial line                                      ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // Purpose:    Send a message over the RS485 bus
.................... // Inputs:     1) The destination address
.................... //             2) The number of bytes of data to send
.................... //             3) A pointer to the data to send
.................... //             4) The length of the data
.................... // Outputs:    TRUE if successful
.................... //             FALSE if failed
.................... // Note:       Format:  source | destination | data-length | data | checksum
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func);
.................... 
.................... // Purpose:    Sends a message stop
.................... // Inputs:     none
.................... // Outputs:    None
.................... void modbus_serial_send_stop();
.................... 
.................... // Purpose:    Puts a character onto the serial line
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_serial_putc(unsigned int8 c);
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////  For Init                                                                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // Purpose:    Enable data reception
.................... // Inputs:     None
.................... // Outputs:    None
.................... void RCV_ON(void);
.................... 
.................... #endif //MODBUS_PHY_LAYER_H
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... //// Shared API                                                                       ////
.................... ////                                                                                  ////
.................... ////  modbus_init()                                                                   ////
.................... ////    - Initialize modbus serial communication system                               ////
.................... ////                                                                                  ////
.................... ////  modbus_kbhit()                                                                  ////
.................... ////    - Used to check if a packet has been received.                                ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // Purpose:    Initialize RS485 communication. Call this before
.................... //             using any other RS485 functions.
.................... // Inputs:     None
.................... // Outputs:    None
.................... void modbus_init();
.................... 
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer
.................... // Inputs:     None
.................... // Outputs:    TRUE if a message was received
.................... //             FALSE if no message is available
.................... // Note:       Data will be filled in at the modbus_rx struct:
.................... int1 modbus_kbhit();
.................... 
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER)
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... //// Master Api                                                                       ////
.................... ////                                                                                  ////
.................... ////  All master API functions return 0 on success.                                   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     ////
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            ////
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         ////
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           ////
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   ////
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           ////
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_exception_status(address)                                 ////
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             ////
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  exception modbus_get_comm_event_counter(address)                                ////
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  exception modbus_get_comm_event_log(address)                                    ////
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   ////
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.////
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  ////
.................... ////                    coils.                                                        ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)///
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. ////
.................... ////    - Special Note: values is a pointer to an int8 array                          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_report_slave_id(address)                                       ////
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  ////
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 ////
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)////
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,////
.................... ////                            write_start,write_quantity, *write_registers_value)   ////
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          ////
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... /********************************************************************
.................... The following structs are used for read/write_sub_request.  These
.................... functions take in one of these structs.
.................... Please refer to the MODBUS protocol specification if you do not
.................... understand the members of the structure.
.................... ********************************************************************/
.................... typedef struct _modbus_read_sub_request
.................... {
....................    unsigned int8 reference_type;
....................    unsigned int16 file_number;
....................    unsigned int16 record_number;
....................    unsigned int16 record_length;
.................... } modbus_read_sub_request;
.................... 
.................... typedef struct _modbus_write_sub_request
.................... {
....................    unsigned int8 reference_type;
....................    unsigned int16 file_number;
....................    unsigned int16 record_number;
....................    unsigned int16 record_length;
....................    unsigned int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8];
.................... } modbus_write_sub_request;
.................... 
.................... /********************************************************************
.................... The following functions are defined in the MODBUS protocol.  Please
.................... refer to http://www.modbus.org for the purpose of each of these.
.................... All functions take the slaves address as their first parameter.
.................... Each function returns the exception code received from the response.
.................... The function will return 0 if there were no errors in transmission.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity);
.................... 
.................... /*
.................... read_discrete_input
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_discrete_input(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity);
.................... /*
.................... read_holding_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_holding_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity);
.................... 
.................... /*
.................... read_input_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_input_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity);
.................... 
.................... /*
.................... write_single_coil
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Address to write into
....................            int1       on                 true for on, false for off
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_single_coil(unsigned int8 address, unsigned int16 output_address, int1 on);
.................... 
.................... /*
.................... write_single_register
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Address to write into
....................            int16      reg_value          Value to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_single_register(unsigned int8 address, unsigned int16 reg_address, unsigned int16 reg_value);
.................... 
.................... /*
.................... read_exception_status
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_exception_status(unsigned int8 address);
.................... 
.................... /*
.................... diagnostics
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Subfunction to send
....................            int16      data               Data to send, changes based on subfunction
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_diagnostics(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data);
.................... 
.................... /*
.................... get_comm_event_couter
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_get_comm_event_counter(unsigned int8 address);
.................... 
.................... /*
.................... get_comm_event_log
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_get_comm_event_log(unsigned int8 address);
.................... 
.................... /*
.................... write_multiple_coils
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start at
....................            int16      quantity           Amount of coils to write to
....................            int1*      values             A pointer to an array holding the values to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_multiple_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity,
....................                            unsigned int8 *values);
.................... 
.................... /*
.................... write_multiple_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start at
....................            int16      quantity           Amount of coils to write to
....................            int16*     values             A pointer to an array holding the data to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_multiple_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity,
....................                            unsigned int16 *values);
.................... 
.................... /*
.................... report_slave_id
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_report_slave_id(unsigned int8 address);
.................... 
.................... /*
.................... read_file_record
.................... Input:     int8                address            Slave Address
....................            int8                byte_count         Number of bytes to read
....................            read_sub_request*   request            Structure holding record information
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_read_file_record(unsigned int8 address, unsigned int8 byte_count,
....................                             modbus_read_sub_request *request);
.................... 
.................... /*
.................... write_file_record
.................... Input:     int8                address            Slave Address
....................            int8                byte_count         Number of bytes to read
....................            read_sub_request*   request            Structure holding record/data information
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_write_file_record(unsigned int8 address, unsigned int8 byte_count,
....................                             modbus_write_sub_request *request);
.................... 
.................... /*
.................... mask_write_register
.................... Input:     int8       address            Slave Address
....................            int16      reference_address  Address to mask
....................            int16      AND_mask           A mask to AND with the data at reference_address
....................            int16      OR_mask            A mask to OR with the data at reference_address
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_mask_write_register(unsigned int8 address, unsigned int16 reference_address,
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask);
.................... 
.................... /*
.................... read_write_multiple_registers
.................... Input:     int8       address                Slave Address
....................            int16      read_start             Address to start reading
....................            int16      read_quantity          Amount of registers to read
....................            int16      write_start            Address to start writing
....................            int16      write_quantity         Amount of registers to write
....................            int16*     write_registers_value  Pointer to an aray us to write
.................... Output:    exception                         0 if no error, else the exception
.................... */
.................... exception modbus_read_write_multiple_registers(unsigned int8 address, unsigned int16 read_start,
....................                                     unsigned int16 read_quantity, unsigned int16 write_start,
....................                                     unsigned int16 write_quantity,
....................                                     unsigned int16 *write_registers_value);
.................... 
.................... /*
.................... read_FIFO_queue
.................... Input:     int8       address           Slave Address
....................            int16      FIFO_address      FIFO address
.................... Output:    exception                    0 if no error, else the exception
.................... */
.................... exception modbus_read_FIFO_queue(unsigned int8 address, unsigned int16 FIFO_address);
.................... 
.................... #else
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... //// Slave API                                                                        ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       ////
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             ////
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            ////
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            ////
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          ////
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            ////
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_exception_status_rsp(address, data)                            ////
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              ////
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        ////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              ////
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    ////
.................... ////                                   *events, events_len)                           ////
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            ////
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        ////
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     ////
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   ////
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  ////
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) ////
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           ////
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         ////
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            ////
.................... ////    - Wrapper to send an exception response.  See exception list below.           ////
.................... ////                                                                                  ////
.................... //// Exception List:                                                                  ////
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     ////
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      ////
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... /********************************************************************
.................... The following structs are used for read/write_sub_request_rsp.  These
.................... functions take in one of these structs.  Please refer to the MODBUS
.................... protocol specification if you do not understand the members of the
.................... structure.
.................... ********************************************************************/
.................... typedef struct _modbus_read_sub_request_rsp
.................... {
....................    unsigned int8 record_length;
....................    unsigned int8 reference_type;
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3];
.................... } modbus_read_sub_request_rsp;
.................... 
.................... typedef struct _modbus_write_sub_request_rsp
.................... {
....................    unsigned int8 reference_type;
....................    unsigned int16 file_number;
....................    unsigned int16 record_number;
....................    unsigned int16 record_length;
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8];
.................... } modbus_write_sub_request_rsp;
.................... 
.................... /********************************************************************
.................... The following slave functions are defined in the MODBUS protocol.
.................... Please refer to http://www.modbus.org for the purpose of each of
.................... these.  All functions take the slaves address as their first
.................... parameter.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      coil_data          Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_coils_rsp(unsigned int8 address, unsigned int8 byte_count, unsigned int8* coil_data);
.................... 
.................... /*
.................... read_discrete_input_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_discrete_input_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                     unsigned int8 *input_data);
.................... 
.................... /*
.................... read_holding_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      reg_data           Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_holding_registers_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                         unsigned int16 *reg_data);
.................... 
.................... /*
.................... read_input_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_input_registers_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                         unsigned int16 *input_data);
.................... 
.................... /*
.................... write_single_coil_rsp
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Echo of output address received
....................            int16      output_value       Echo of output value received
.................... Output:    void
.................... */
.................... void modbus_write_single_coil_rsp(unsigned int8 address, unsigned int16 output_address,
....................                                     unsigned int16 output_value);
.................... 
.................... /*
.................... write_single_register_rsp
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Echo of register address received
....................            int16      reg_value          Echo of register value received
.................... Output:    void
.................... */
.................... void modbus_write_single_register_rsp(unsigned int8 address, unsigned int16 reg_address,
....................                                         unsigned int16 reg_value);
.................... 
.................... /*
.................... read_exception_status_rsp
.................... Input:     int8       address            Slave Address
.................... Output:    void
.................... */
.................... void modbus_read_exception_status_rsp(unsigned int8 address, unsigned int8 data);
.................... 
.................... /*
.................... diagnostics_rsp
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Echo of sub function received
....................            int16      data               Echo of data received
.................... Output:    void
.................... */
.................... void modbus_diagnostics_rsp(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data);
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_counter_rsp(unsigned int8 address, unsigned int16 status,
....................                                         unsigned int16 event_count);
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
....................            int16      message_count      Count of messages
....................            int8*      events             Pointer to event data
....................            int8       events_len         Length of event data in bytes
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_log_rsp(unsigned int8 address, unsigned int16 status,
....................                                     unsigned int16 event_count, unsigned int16 message_count,
....................                                     unsigned int8 *events, unsigned int8 events_len);
.................... 
.................... /*
.................... write_multiple_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of coils written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_coils_rsp(unsigned int8 address, unsigned int16 start_address,
....................                                         unsigned int16 quantity);
.................... 
.................... /*
.................... write_multiple_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of registers written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_registers_rsp(unsigned int8 address, unsigned int16 start_address,
....................                                             unsigned int16 quantity);
.................... 
.................... /*
.................... report_slave_id_rsp
.................... Input:     int8       address            Slave Address
....................            int8       slave_id           Slave Address
....................            int8       run_status         Are we running?
....................            int8*      data               Pointer to an array holding the data
....................            int8       data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_report_slave_id_rsp(unsigned int8 address, unsigned int8 slave_id, unsigned int1 run_status,
....................                               unsigned int8 *data, unsigned int8 data_len);
.................... 
.................... /*
.................... read_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Number of bytes to send
....................            read_sub_request_rsp*    request            Structure holding record/data information
.................... Output:    void
.................... */
.................... void modbus_read_file_record_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                     modbus_read_sub_request_rsp *request);
.................... 
.................... /*
.................... write_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Echo of number of bytes sent
....................            write_sub_request_rsp*   request            Echo of Structure holding record information
.................... Output:    void
.................... */
.................... void modbus_write_file_record_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                     modbus_write_sub_request_rsp *request);
.................... 
.................... /*
.................... mask_write_register_rsp
.................... Input:     int8        address            Slave Address
....................            int16       reference_address  Echo of reference address
....................            int16       AND_mask           Echo of AND mask
....................            int16       OR_mask            Echo or OR mask
.................... Output:    void
.................... */
.................... void modbus_mask_write_register_rsp(unsigned int8 address, unsigned int16 reference_address,
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask);
.................... 
.................... /*
.................... read_write_multiple_registers_rsp
.................... Input:     int8        address            Slave Address
....................            int16*      data               Pointer to an array of data
....................            int8        data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_read_write_multiple_registers_rsp(unsigned int8 address, unsigned int8 data_len,
....................                                                 unsigned int16 *data);
.................... 
.................... /*
.................... read_FIFO_queue_rsp
.................... Input:     int8        address            Slave Address
....................            int16       FIFO_len           Length of FIFO in bytes
....................            int16*      data               Pointer to an array of data
.................... Output:    void
.................... */
.................... void modbus_read_FIFO_queue_rsp(unsigned int8 address, unsigned int16 FIFO_len, unsigned int16 *data);
.................... 
.................... void modbus_exception_rsp(unsigned int8 address, unsigned int16 func, exception error);
.................... #endif //MODBUS_TYPE
.................... 
.................... #endif //MODBUS_APP_LAYER_H
.................... 
.................... #endif
.................... 
.................... #endif //MODBUS_H
.................... 
.................... 
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_SERIAL)
....................  #if (MODBUS_SERIAL_TYPE == MODBUS_RTU)
....................   #include <modbus_phy_layer_rtu.c>
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                              modbus_phy_layer_rtu.c                              ////
.................... ////                                                                                  ////
.................... ////      Physical layer of the MODBUS protocol driver for serial communications.     ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MODBUS_PHY_LAYER_RTU_C
.................... #define MODBUS_PHY_LAYER_RTU_C
.................... 
.................... #include <modbus_phy_layer.h>
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                modbus_phy_layer.h                                ////
.................... ////                                                                                  ////
.................... ////      Physical layer of the MODBUS protocol driver for serial communications.     ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// Revision history:                                                                ////
.................... ////                                                                                  ////
.................... ////  Sept 22, 2020       Updated TRMT bit variable for PIC18 devices with new UART   ////
.................... ////                      peripherial.  Added support for using UART5 and UART6 for   ////
.................... ////                      devices that have UART5 and UART6 peripherals.              ////
.................... ////                                                                                  ////
.................... ////  July 20, 2011       Seperated Physical Layer functions definitions into this    ////
.................... ////                      file from modbus.c                                          ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MODBUS_PHY_LAYER_H
.................... #define MODBUS_PHY_LAYER_H
.................... 
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER)
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU)
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\
.................... {\
....................    modbus_timeout_enabled = 0;\
....................    if(address)\
....................    {\
....................       while(!modbus_kbhit() && --modbus_serial_wait)\
....................          delay_us(1);\
....................       if(!modbus_serial_wait)\
....................          modbus_rx.error=TIMEOUT;\
....................    }\
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\
.................... }
.................... #else
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\
.................... {\
....................    if(address)\
....................    {\
....................       while(!modbus_kbhit() && --modbus_serial_wait)\
....................          delay_us(1);\
....................       if(!modbus_serial_wait)\
....................          modbus_rx.error=TIMEOUT;\
....................    }\
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\
.................... }
.................... #endif
.................... #endif
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT)
....................    #if defined(__PCD__)
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA)
....................          #word TXSTA=getenv("SFR:U1STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2)
....................          #word TXSTA=getenv("SFR:U2STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3)
....................          #word TXSTA=getenv("SFR:U3STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4)
....................          #word TXSTA=getenv("SFR:U4STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA5)
....................          #word TXSTA=getenv("SFR:U5STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA6)
....................          #word TXSTA=getenv("SFR:U6STA")
....................          #bit TRMT=TXSTA.8
....................       #endif
....................    #else
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA)
....................          #if getenv("sfr_valid:U1ERRIR")
....................             #byte TXSTA=getenv("SFR:U1ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA")
....................             #byte TXSTA=getenv("sfr:TXSTA")
....................             #bit TRMT=TXSTA.1
....................          #elif getenv("sfr_valid:TXSTA1")
....................             #byte TXSTA=getenv("sfr:TXSTA1")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX1STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2)
....................          #if getenv("sfr_valid:U2ERRIR")
....................             #byte TXSTA=getenv("SFR:U2ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA2")
....................             #byte TXSTA=getenv("sfr:TXSTA2")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX2STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3)
....................          #if getenv("sfr_valid:U3ERRIR")
....................             #byte TXSTA=getenv("SFR:U3ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA3")
....................             #byte TXSTA=getenv("sfr:TXSTA3")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX3STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4)
....................          #if getenv("sfr_valid:U4ERRIR")
....................             #byte TXSTA=getenv("SFR:U4ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA4")
....................             #byte TXSTA=getenv("sfr:TXSTA4")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX4STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA5)
....................          #if getenv("sfr_valid:U5ERRIR")
....................             #byte TXSTA=getenv("SFR:U5ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA5")
....................             #byte TXSTA=getenv("sfr:TXSTA5")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX5STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA6)
....................          #if getenv("sfr_valid:U6ERRIR")
....................             #byte TXSTA=getenv("SFR:U6ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA6")
....................             #byte TXSTA=getenv("sfr:TXSTA6")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX6STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................       #endif
....................    #endif
.................... #endif
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT)
.................... #define WAIT_FOR_HW_BUFFER()\
.................... {\
....................    while(!TRMT);\
.................... }
.................... #endif
.................... 
.................... int1 modbus_serial_new=0;
.................... 
.................... /********************************************************************
.................... These exceptions are defined in the MODBUS protocol.  These can be
.................... used by the slave to communicate problems with the transmission back
.................... to the master who can also use these to easily check the exceptions.
.................... The first exception is the only one that is not part of the protocol
.................... specification.  The TIMEOUT exception is returned when no slave
.................... responds to the master's request within the timeout period.
.................... ********************************************************************/
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11,
.................... TIMEOUT=12} exception;
.................... 
.................... /********************************************************************
.................... These functions are defined in the MODBUS protocol.  These can be
.................... used by the slave to check the incomming function.  See
.................... ex_modbus_slave.c for example usage.
.................... ********************************************************************/
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02,
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04,
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06,
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08,
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C,
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10,
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14,
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16,
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function;
.................... 
.................... /********************************************************************
.................... Our receive struct.  This is used when receiving data as a master or
.................... slave.  Once a message is sent to you with your address, you should
.................... begin processing that message.  Refer to ex_modbus_slave.c to see
.................... how to properly use this structure.
.................... ********************************************************************/
.................... struct
.................... {
....................    unsigned int8 address;
....................    unsigned int8 len;                       //number of bytes in the message received
....................    function func;                           //the function of the message received
....................    exception error;                         //error recieved, if any
....................    unsigned int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received
.................... } modbus_rx;
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////  For Custom Commands                                                             ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_start(address,func)                                          ////
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data ////
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_stop()                                                       ////
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_putc(unsigned int8 c)                                             ////
.................... ////    - Sends a character onto the serial line                                      ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // Purpose:    Send a message over the RS485 bus
.................... // Inputs:     1) The destination address
.................... //             2) The number of bytes of data to send
.................... //             3) A pointer to the data to send
.................... //             4) The length of the data
.................... // Outputs:    TRUE if successful
.................... //             FALSE if failed
.................... // Note:       Format:  source | destination | data-length | data | checksum
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func);
.................... 
.................... // Purpose:    Sends a message stop
.................... // Inputs:     none
.................... // Outputs:    None
.................... void modbus_serial_send_stop();
.................... 
.................... // Purpose:    Puts a character onto the serial line
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_serial_putc(unsigned int8 c);
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////  For Init                                                                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // Purpose:    Enable data reception
.................... // Inputs:     None
.................... // Outputs:    None
.................... void RCV_ON(void);
.................... 
.................... #endif //MODBUS_PHY_LAYER_H
.................... 
.................... 
.................... #if (MODBUS_TIMER_USED == MODBUS_TIMER_T1)
....................   #if (MODBUS_TIMER_UPDATE == MODBUS_TIMER_ISR)
....................     #USE TIMER(TIMER=1,TICK=.1ms,BITS=16, ISR)
*
0326:  MOVFF  8B,00
032A:  MOVFF  8C,01
032E:  CLRF   02
0330:  BCF    FD8.0
0332:  RLCF   00,F
0334:  RLCF   01,F
0336:  RLCF   02,F
0338:  BCF    FD8.0
033A:  RLCF   00,F
033C:  RLCF   01,F
033E:  RLCF   02,F
0340:  BCF    FD8.0
0342:  RLCF   00,F
0344:  RLCF   01,F
0346:  RLCF   02,F
0348:  BCF    FD8.0
034A:  RLCF   00,F
034C:  RLCF   01,F
034E:  RLCF   02,F
0350:  BCF    FD8.0
0352:  RLCF   00,F
0354:  RLCF   01,F
0356:  RLCF   02,F
0358:  MOVFF  02,5F
035C:  MOVFF  01,FCF
0360:  MOVFF  00,FCE
0364:  RETURN 0
*
06D2:  MOVFF  5F,01
06D6:  MOVF   FCE,W
06D8:  MOVFF  FCF,03
06DC:  BCF    F9D.0
06DE:  MOVWF  02
06E0:  MOVF   5F,W
06E2:  SUBWF  01,W
06E4:  BZ    06EE
06E6:  MOVF   FCE,W
06E8:  MOVFF  FCF,03
06EC:  BRA    06F0
06EE:  MOVF   02,W
06F0:  MOVWF  00
06F2:  MOVFF  03,01
06F6:  MOVFF  5F,02
06FA:  RRCF   02,F
06FC:  RRCF   01,F
06FE:  RRCF   00,F
0700:  RRCF   02,F
0702:  RRCF   01,F
0704:  RRCF   00,F
0706:  RRCF   02,F
0708:  RRCF   01,F
070A:  RRCF   00,F
070C:  RRCF   02,F
070E:  RRCF   01,F
0710:  RRCF   00,F
0712:  RRCF   02,F
0714:  RRCF   01,F
0716:  RRCF   00,F
0718:  BSF    F9D.0
071A:  GOTO   075A (RETURN)
....................   #else
....................     #USE TIMER(TIMER=1,TICK=.1ms,BITS=16, NOISR)
....................   #endif
.................... #elif (MODBUS_TIMER_USED == MODBUS_TIMER_T2)
....................   #if (MODBUS_TIMER_UPDATE == MODBUS_TIMER_ISR)
....................     #USE TIMER(TIMER=2,TICK=.1ms,BITS=16, ISR)
....................   #else
....................     #USE TIMER(TIMER=2,TICK=.1ms,BITS=16, NOISR)
....................   #endif
.................... #endif
.................... 
.................... #define MODBUS_GETDATA_TIMEOUT 40
.................... 
.................... #if( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA )
....................   #if MODBUS_PARITY == "EVEN"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors)
*
02F6:  BTFSS  F9E.5
02F8:  BRA    02F6
02FA:  MOVFF  FAB,60
02FE:  MOVFF  FAE,01
0302:  MOVLW  08
0304:  MOVWF  x8B
0306:  CLRF   x8A
0308:  MOVFF  FAE,00
030C:  MOVF   00,W
030E:  XORWF  x8A,F
0310:  RRCF   00,F
0312:  DECFSZ x8B,F
0314:  BRA    030C
0316:  MOVLW  01
0318:  ANDWF  x8A,W
031A:  XORWF  60,F
031C:  BTFSS  60.1
031E:  BRA    0324
0320:  BCF    FAB.4
0322:  BSF    FAB.4
0324:  RETURN 0
*
063E:  MOVLW  08
0640:  MOVWF  01
0642:  CLRF   x85
0644:  MOVFF  84,00
0648:  MOVF   00,W
064A:  XORWF  x85,F
064C:  RRCF   00,F
064E:  DECFSZ 01,F
0650:  BRA    0648
0652:  BTFSS  F9E.4
0654:  BRA    0652
0656:  MOVLW  FE
0658:  ANDWF  FAC,F
065A:  BTFSC  x85.0
065C:  BSF    FAC.0
065E:  MOVFF  84,FAD
0662:  GOTO   066C (RETURN)
....................   #elif MODBUS_PARITY == "ODD"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors)
....................   #else
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors)
....................   #endif
....................    #define RCV_OFF() {disable_interrupts(INT_RDA);}
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2 )
....................   #if MODBUS_PARITY == "EVEN"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors)
....................   #elif MODBUS_PARITY == "ODD"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors)
....................   #else
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors)
....................   #endif
....................    #define RCV_OFF() {disable_interrupts(INT_RDA2);}
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3 )
....................   #if MODBUS_PARITY == "EVEN"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors)
....................   #elif MODBUS_PARITY == "ODD"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors)
....................   #else
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors)
....................   #endif
....................    #define RCV_OFF() {disable_interrupts(INT_RDA3);}
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4 )
....................   #if MODBUS_PARITY == "EVEN"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors)
....................   #elif MODBUS_PARITY == "ODD"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors)
....................   #else
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors)
....................   #endif
....................    #define RCV_OFF() {disable_interrupts(INT_RDA4);}
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA5 )
....................   #if MODBUS_PARITY == "EVEN"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART5, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors)
....................   #elif MODBUS_PARITY == "ODD"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART5, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors)
....................   #else
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART5, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors)
....................   #endif
....................    #define RCV_OFF() {disable_interrupts(INT_RDA5);}
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA6 )
....................   #if MODBUS_PARITY == "EVEN"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART6, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors)
....................   #elif MODBUS_PARITY == "ODD"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART6, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors)
....................   #else
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART6, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors)
....................   #endif
....................    #define RCV_OFF() {disable_interrupts(INT_RDA6);}
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_EXT )
....................   #if MODBUS_PARITY == "EVEN"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, disable_ints)
....................   #elif MODBUS_PARITY == "ODD"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, disable_ints)
....................   #else
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, disable_ints)
....................   #endif
....................    #if defined(__PCD__)
....................    #define RCV_OFF() {disable_interrupts(INT_EXT0);}
....................    #else
....................    #define RCV_OFF() {disable_interrupts(INT_EXT);}
....................    #endif
.................... #else
....................    #error Please define a correct interrupt source
.................... #endif
.................... 
.................... /* status of between byte timeout */
.................... int1 modbus_timeout_enabled = FALSE;
.................... 
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER)
.................... unsigned int32 modbus_serial_wait=MODBUS_SERIAL_TIMEOUT;
.................... #endif
.................... 
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0;
.................... 
.................... 
.................... /*Global value holding our current CRC value.*/
.................... union
.................... {
....................    unsigned int8 b[2];
....................    unsigned int16 d;
.................... } modbus_serial_crc;
.................... 
.................... 
.................... /* Table of CRC values for highorder byte */
.................... const unsigned char modbus_auchCRCHi[] = {
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40
.................... };
.................... 
.................... /* Table of CRC values for loworder byte */
.................... const unsigned char modbus_auchCRCLo[] = {
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4,
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09,
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD,
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3,
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7,
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE,
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2,
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB,
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5,
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91,
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C,
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88,
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C,
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80,
.................... 0x40
.................... };
.................... 
.................... // Purpose:    Enable data reception
.................... // Inputs:     None
.................... // Outputs:    None
.................... void RCV_ON(void)
.................... {
....................    #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT)
....................       while(kbhit(MODBUS_SERIAL)) {fgetc(MODBUS_SERIAL);}  //Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag.
*
0418:  BTFSS  F9E.5
041A:  BRA    042C
041C:  CLRF   19
041E:  BTFSC  FF2.7
0420:  BSF    19.7
0422:  BCF    FF2.7
0424:  RCALL  02F6
0426:  BTFSC  19.7
0428:  BSF    FF2.7
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA)
042A:  BRA    0418
....................          clear_interrupt(INT_RDA);
042C:  MOVF   FAE,W
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2)
....................          clear_interrupt(INT_RDA2);
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3)
....................          clear_interrupt(INT_RDA3);
....................       #else
....................          clear_interrupt(INT_RDA4);
....................       #endif
.................... 
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0)
....................          output_low(MODBUS_SERIAL_RX_ENABLE);
042E:  BCF    F95.2
0430:  BCF    F8C.2
....................       #endif
.................... 
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA)
....................         enable_interrupts(INT_RDA);
0432:  BSF    F9D.5
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2)
....................         enable_interrupts(INT_RDA2);
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3)
....................         enable_interrupts(INT_RDA3);
....................       #else
....................         enable_interrupts(INT_RDA4);
....................       #endif
....................    #else
0434:  RETURN 0
....................       #if defined(__PCD__)
....................          clear_interrupt(INT_EXT0);
....................       #else
....................          clear_interrupt(INT_EXT);
....................       #endif
.................... 
....................       ext_int_edge(H_TO_L);
.................... 
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0)
....................          output_low(MODBUS_SERIAL_RX_ENABLE);
....................       #endif
.................... 
....................       #if defined(__PCD__)
....................          enable_interrupts(INT_EXT0);
....................       #else
....................          enable_interrupts(INT_EXT);
....................       #endif
....................    #endif
.................... }
.................... 
.................... // Purpose:    Start our timeout timer
.................... // Inputs:     Enable, used to turn timer on/off
.................... // Outputs:    None
.................... // Not used for ASCII mode
.................... void modbus_enable_timeout(int1 enable)
.................... {
....................    modbus_timeout_enabled = enable;
*
0366:  BCF    1A.1
0368:  BTFSC  x8A.0
036A:  BSF    1A.1
....................    set_ticks(0);
036C:  CLRF   x8C
036E:  CLRF   x8B
0370:  RCALL  0326
0372:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Handles a timeout when waiting for a response
.................... // Inputs:     None
.................... // Outputs:    None
.................... // Not used for ASCII mode
.................... void modbus_timeout_now(void)
.................... {
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new))
*
071E:  MOVF   65,W
0720:  SUBLW  02
0722:  BNZ   0738
0724:  MOVF   66,F
0726:  BNZ   0738
0728:  MOVF   67,F
072A:  BNZ   0738
072C:  BTFSC  1A.0
072E:  BRA    0738
....................    {
....................       modbus_rx.len-=2;
0730:  MOVLW  02
0732:  SUBWF  1C,F
....................       modbus_serial_new=TRUE;
0734:  BSF    1A.0
....................    } else {
0736:  BRA    073A
....................       modbus_serial_new=FALSE;
0738:  BCF    1A.0
....................    }
.................... 
....................    modbus_serial_crc.d=0xFFFF;
073A:  SETF   67
073C:  SETF   66
....................    modbus_serial_state=MODBUS_GETADDY;
073E:  CLRF   65
0740:  CLRF   19
0742:  BTFSC  FF2.7
0744:  BSF    19.7
0746:  BCF    FF2.7
....................    modbus_enable_timeout(FALSE);
0748:  CLRF   x8A
074A:  RCALL  0366
074C:  BTFSC  19.7
074E:  BSF    FF2.7
0750:  GOTO   076E (RETURN)
.................... }
.................... 
.................... // Purpose:    Check if we have timed out waiting for a response
.................... // Inputs:     None
.................... // Outputs:    None
.................... // Not used for ASCII mode
.................... void modbus_check_timeout(void)
.................... {
....................    #if (MODBUS_TIMER_UPDATE == MODBUS_TIMER_NOISR)
....................    //get_ticks() must be called more often than the timer overflow
....................    //rate, and the get_ticks() below will not always be called
....................    //due to short circuit evaluation
....................    get_ticks();
....................    #endif
....................    //modbus_timeout_enabled must be checked before get_ticks()
....................    //so that if an interrupt happens it cannot be enabled after
....................    //an old timer value is used in comparison
....................    if(modbus_timeout_enabled && (get_ticks() > MODBUS_GETDATA_TIMEOUT))
0754:  BTFSS  1A.1
0756:  BRA    076E
0758:  BRA    06D2
075A:  MOVFF  01,82
075E:  MOVFF  00,81
0762:  MOVF   x82,F
0764:  BNZ   076C
0766:  MOVF   x81,W
0768:  SUBLW  28
076A:  BC    076E
....................    {
....................      modbus_timeout_now();
076C:  BRA    071E
....................    }
076E:  GOTO   0774 (RETURN)
.................... }
.................... 
.................... // Purpose:    Calculate crc of data and updates global crc
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_calc_crc(char data)
.................... {
....................    unsigned int8 uIndex ; // will index into CRC lookup table
.................... 
....................    uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC
*
0374:  MOVF   67,W
0376:  XORWF  x8A,W
0378:  MOVWF  x8B
....................    modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex];
037A:  CLRF   03
037C:  MOVF   x8B,W
037E:  RCALL  00BA
0380:  MOVWF  01
0382:  MOVF   66,W
0384:  XORWF  01,W
0386:  MOVWF  67
....................    modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex];
0388:  CLRF   03
038A:  MOVF   x8B,W
038C:  RCALL  01CA
038E:  MOVWF  66
0390:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Puts a character onto the serial line
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_serial_putc(unsigned int8 c)
.................... {
....................    fputc(c, MODBUS_SERIAL);
*
0666:  MOVFF  83,84
066A:  BRA    063E
066C:  CLRF   19
066E:  BTFSC  FF2.7
0670:  BSF    19.7
0672:  BCF    FF2.7
....................    modbus_calc_crc(c);
0674:  MOVFF  83,8A
0678:  RCALL  0374
067A:  BTFSC  19.7
067C:  BSF    FF2.7
....................    delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact
067E:  MOVLW  45
0680:  MOVWF  00
0682:  DECFSZ 00,F
0684:  BRA    0682
0686:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Send a message over the RS485 bus
.................... // Inputs:     1) The destination address
.................... //             2) The number of bytes of data to send
.................... //             3) A pointer to the data to send
.................... //             4) The length of the data
.................... // Outputs:    TRUE if successful
.................... //             FALSE if failed
.................... // Note:       Format:  source | destination | data-length | data | checksum
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func)
.................... {
....................    modbus_serial_crc.d=0xFFFF;
0688:  SETF   67
068A:  SETF   66
....................    modbus_serial_new=FALSE;
068C:  BCF    1A.0
.................... 
....................    RCV_OFF();
068E:  BCF    F9D.5
.................... 
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0)
....................    output_high(MODBUS_SERIAL_ENABLE_PIN);
.................... #endif
.................... 
....................    delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay
0690:  MOVLW  F2
0692:  MOVWF  00
0694:  DECFSZ 00,F
0696:  BRA    0694
0698:  NOP   
.................... 
....................    modbus_serial_putc(to);
069A:  MOVFF  81,83
069E:  RCALL  0666
....................    modbus_serial_putc(func);
06A0:  MOVFF  82,83
06A4:  RCALL  0666
06A6:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Ends a message over the RS485 Bus
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_serial_send_stop()
.................... {
....................    unsigned int8 crc_low, crc_high;
.................... 
....................    crc_high=modbus_serial_crc.b[1];
06A8:  MOVFF  67,82
....................    crc_low=modbus_serial_crc.b[0];
06AC:  MOVFF  66,81
.................... 
....................    modbus_serial_putc(crc_high);
06B0:  MOVFF  82,83
06B4:  RCALL  0666
....................    modbus_serial_putc(crc_low);
06B6:  MOVFF  81,83
06BA:  RCALL  0666
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT)
....................    WAIT_FOR_HW_BUFFER();
06BC:  BTFSS  FAC.1
06BE:  BRA    06BC
.................... #endif
.................... 
....................    delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay
06C0:  MOVLW  F2
06C2:  MOVWF  00
06C4:  DECFSZ 00,F
06C6:  BRA    06C4
06C8:  NOP   
.................... 
....................    RCV_ON();
06CA:  RCALL  0418
.................... 
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0)
....................    output_low(MODBUS_SERIAL_ENABLE_PIN);
.................... #endif
.................... 
....................    modbus_serial_crc.d=0xFFFF;
06CC:  SETF   67
06CE:  SETF   66
06D0:  RETURN 0
.................... }
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... //// Interrupts    ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA)
.................... #int_rda
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2)
.................... #int_rda2
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3)
.................... #int_rda3
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA4)
.................... #int_rda4
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA5)
.................... #int_rda5
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA6)
.................... #int_rda6
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_EXT)
.................... #if defined(__PCD__)
.................... #int_ext1
.................... #else
.................... #int_ext
.................... #endif
.................... #else
.................... #error Please define a correct interrupt source
.................... #endif
.................... void incomming_modbus_serial() {
....................    char c;
....................    c=fgetc(MODBUS_SERIAL);
*
0392:  RCALL  02F6
0394:  MOVFF  01,89
.................... 
....................    if (!modbus_serial_new)
0398:  BTFSC  1A.0
039A:  BRA    03EC
....................    {
....................       if(modbus_serial_state == MODBUS_GETADDY)
039C:  MOVF   65,F
039E:  BNZ   03B0
....................       {
....................          modbus_serial_crc.d = 0xFFFF;
03A0:  SETF   67
03A2:  SETF   66
....................          modbus_rx.address = c;
03A4:  MOVFF  89,1B
....................          modbus_serial_state++;
03A8:  INCF   65,F
....................          modbus_rx.len = 0;
03AA:  CLRF   1C
....................          modbus_rx.error=0;
03AC:  CLRF   1E
....................       }
03AE:  BRA    03E0
....................       else if(modbus_serial_state == MODBUS_GETFUNC)
03B0:  DECFSZ 65,W
03B2:  BRA    03BC
....................       {
....................          modbus_rx.func = c;
03B4:  MOVFF  89,1D
....................          modbus_serial_state++;
03B8:  INCF   65,F
....................       }
03BA:  BRA    03E0
....................       else if(modbus_serial_state == MODBUS_GETDATA)
03BC:  MOVF   65,W
03BE:  SUBLW  02
03C0:  BNZ   03E0
....................       {
....................          if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE)
03C2:  MOVF   1C,W
03C4:  SUBLW  3F
03C6:  BC    03CC
....................        {
....................          modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1;
03C8:  MOVLW  3F
03CA:  MOVWF  1C
....................        }
....................          modbus_rx.data[modbus_rx.len]=c;
03CC:  CLRF   03
03CE:  MOVF   1C,W
03D0:  ADDLW  1F
03D2:  MOVWF  FE9
03D4:  MOVLW  00
03D6:  ADDWFC 03,W
03D8:  MOVWF  FEA
03DA:  MOVFF  89,FEF
....................          modbus_rx.len++;
03DE:  INCF   1C,F
....................      }
....................      modbus_enable_timeout(TRUE);
03E0:  MOVLW  01
03E2:  MOVWF  x8A
03E4:  RCALL  0366
....................      modbus_calc_crc(c);
03E6:  MOVFF  89,8A
03EA:  RCALL  0374
.................... 
....................    }
.................... 
....................    #if (MODBUS_TYPE == MODBUS_TYPE_MASTER)
....................       modbus_serial_wait=MODBUS_SERIAL_TIMEOUT;
03EC:  CLRF   64
03EE:  CLRF   63
03F0:  MOVLW  27
03F2:  MOVWF  62
03F4:  MOVLW  10
03F6:  MOVWF  61
....................    #endif
.................... }
.................... #endif //MODBUS_PHY_LAYER_RTU_C
.................... 
....................  #elif (MODBUS_SERIAL_TYPE == MODBUS_ASCII)
....................   #include <modbus_phy_layer_ascii.c>
....................  #endif
.................... #else
....................  #include <modbus_phy_layer_tcpip.c>
.................... #endif
.................... 
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_TCPIP)
....................  #include <modbus_app_layer_tcpip.c>
.................... #else
....................  #include <modbus_app_layer.c>
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                modbus_app_layer.c                                ////
.................... ////                                                                                  ////
.................... ////    Application layer of the MODBUS protocol driver for serial communications.    ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MODBUS_APP_LAYER_C
.................... #define MODBUS_APP_LAYER_C
.................... 
.................... #include <modbus_app_layer.h>
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                modbus_app_layer.h                                ////
.................... ////                                                                                  ////
.................... ////    Application layer of the MODBUS protocol driver for serial communications.    ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// Revision history:                                                                ////
.................... ////  July 20, 2011       Seperated App Layer functions into this file from modbus.c  ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
03F8:  BCF    F9E.5
03FA:  GOTO   006C
.................... #ifndef MODBUS_APP_LAYER_H
.................... #define MODBUS_APP_LAYER_H
.................... 
.................... #include <modbus_phy_layer.h>
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... //// Shared API                                                                       ////
.................... ////                                                                                  ////
.................... ////  modbus_init()                                                                   ////
.................... ////    - Initialize modbus serial communication system                               ////
.................... ////                                                                                  ////
.................... ////  modbus_kbhit()                                                                  ////
.................... ////    - Used to check if a packet has been received.                                ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // Purpose:    Initialize RS485 communication. Call this before
.................... //             using any other RS485 functions.
.................... // Inputs:     None
.................... // Outputs:    None
.................... void modbus_init();
.................... 
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer
.................... // Inputs:     None
.................... // Outputs:    TRUE if a message was received
.................... //             FALSE if no message is available
.................... // Note:       Data will be filled in at the modbus_rx struct:
.................... int1 modbus_kbhit();
.................... 
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER)
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... //// Master Api                                                                       ////
.................... ////                                                                                  ////
.................... ////  All master API functions return 0 on success.                                   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     ////
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            ////
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         ////
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           ////
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   ////
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           ////
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_exception_status(address)                                 ////
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             ////
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  exception modbus_get_comm_event_counter(address)                                ////
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  exception modbus_get_comm_event_log(address)                                    ////
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   ////
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.////
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  ////
.................... ////                    coils.                                                        ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)///
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. ////
.................... ////    - Special Note: values is a pointer to an int8 array                          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_report_slave_id(address)                                       ////
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  ////
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 ////
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)////
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,////
.................... ////                            write_start,write_quantity, *write_registers_value)   ////
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          ////
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... /********************************************************************
.................... The following structs are used for read/write_sub_request.  These
.................... functions take in one of these structs.
.................... Please refer to the MODBUS protocol specification if you do not
.................... understand the members of the structure.
.................... ********************************************************************/
.................... typedef struct _modbus_read_sub_request
.................... {
....................    unsigned int8 reference_type;
....................    unsigned int16 file_number;
....................    unsigned int16 record_number;
....................    unsigned int16 record_length;
.................... } modbus_read_sub_request;
.................... 
.................... typedef struct _modbus_write_sub_request
.................... {
....................    unsigned int8 reference_type;
....................    unsigned int16 file_number;
....................    unsigned int16 record_number;
....................    unsigned int16 record_length;
....................    unsigned int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8];
.................... } modbus_write_sub_request;
.................... 
.................... /********************************************************************
.................... The following functions are defined in the MODBUS protocol.  Please
.................... refer to http://www.modbus.org for the purpose of each of these.
.................... All functions take the slaves address as their first parameter.
.................... Each function returns the exception code received from the response.
.................... The function will return 0 if there were no errors in transmission.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity);
.................... 
.................... /*
.................... read_discrete_input
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_discrete_input(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity);
.................... /*
.................... read_holding_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_holding_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity);
.................... 
.................... /*
.................... read_input_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_input_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity);
.................... 
.................... /*
.................... write_single_coil
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Address to write into
....................            int1       on                 true for on, false for off
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_single_coil(unsigned int8 address, unsigned int16 output_address, int1 on);
.................... 
.................... /*
.................... write_single_register
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Address to write into
....................            int16      reg_value          Value to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_single_register(unsigned int8 address, unsigned int16 reg_address, unsigned int16 reg_value);
.................... 
.................... /*
.................... read_exception_status
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_exception_status(unsigned int8 address);
.................... 
.................... /*
.................... diagnostics
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Subfunction to send
....................            int16      data               Data to send, changes based on subfunction
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_diagnostics(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data);
.................... 
.................... /*
.................... get_comm_event_couter
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_get_comm_event_counter(unsigned int8 address);
.................... 
.................... /*
.................... get_comm_event_log
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_get_comm_event_log(unsigned int8 address);
.................... 
.................... /*
.................... write_multiple_coils
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start at
....................            int16      quantity           Amount of coils to write to
....................            int1*      values             A pointer to an array holding the values to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_multiple_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity,
....................                            unsigned int8 *values);
.................... 
.................... /*
.................... write_multiple_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start at
....................            int16      quantity           Amount of coils to write to
....................            int16*     values             A pointer to an array holding the data to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_multiple_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity,
....................                            unsigned int16 *values);
.................... 
.................... /*
.................... report_slave_id
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_report_slave_id(unsigned int8 address);
.................... 
.................... /*
.................... read_file_record
.................... Input:     int8                address            Slave Address
....................            int8                byte_count         Number of bytes to read
....................            read_sub_request*   request            Structure holding record information
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_read_file_record(unsigned int8 address, unsigned int8 byte_count,
....................                             modbus_read_sub_request *request);
.................... 
.................... /*
.................... write_file_record
.................... Input:     int8                address            Slave Address
....................            int8                byte_count         Number of bytes to read
....................            read_sub_request*   request            Structure holding record/data information
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_write_file_record(unsigned int8 address, unsigned int8 byte_count,
....................                             modbus_write_sub_request *request);
.................... 
.................... /*
.................... mask_write_register
.................... Input:     int8       address            Slave Address
....................            int16      reference_address  Address to mask
....................            int16      AND_mask           A mask to AND with the data at reference_address
....................            int16      OR_mask            A mask to OR with the data at reference_address
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_mask_write_register(unsigned int8 address, unsigned int16 reference_address,
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask);
.................... 
.................... /*
.................... read_write_multiple_registers
.................... Input:     int8       address                Slave Address
....................            int16      read_start             Address to start reading
....................            int16      read_quantity          Amount of registers to read
....................            int16      write_start            Address to start writing
....................            int16      write_quantity         Amount of registers to write
....................            int16*     write_registers_value  Pointer to an aray us to write
.................... Output:    exception                         0 if no error, else the exception
.................... */
.................... exception modbus_read_write_multiple_registers(unsigned int8 address, unsigned int16 read_start,
....................                                     unsigned int16 read_quantity, unsigned int16 write_start,
....................                                     unsigned int16 write_quantity,
....................                                     unsigned int16 *write_registers_value);
.................... 
.................... /*
.................... read_FIFO_queue
.................... Input:     int8       address           Slave Address
....................            int16      FIFO_address      FIFO address
.................... Output:    exception                    0 if no error, else the exception
.................... */
.................... exception modbus_read_FIFO_queue(unsigned int8 address, unsigned int16 FIFO_address);
.................... 
.................... #else
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... //// Slave API                                                                        ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       ////
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             ////
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            ////
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            ////
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          ////
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            ////
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_exception_status_rsp(address, data)                            ////
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              ////
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        ////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              ////
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    ////
.................... ////                                   *events, events_len)                           ////
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            ////
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        ////
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     ////
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   ////
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  ////
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) ////
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           ////
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         ////
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            ////
.................... ////    - Wrapper to send an exception response.  See exception list below.           ////
.................... ////                                                                                  ////
.................... //// Exception List:                                                                  ////
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     ////
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      ////
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... /********************************************************************
.................... The following structs are used for read/write_sub_request_rsp.  These
.................... functions take in one of these structs.  Please refer to the MODBUS
.................... protocol specification if you do not understand the members of the
.................... structure.
.................... ********************************************************************/
.................... typedef struct _modbus_read_sub_request_rsp
.................... {
....................    unsigned int8 record_length;
....................    unsigned int8 reference_type;
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3];
.................... } modbus_read_sub_request_rsp;
.................... 
.................... typedef struct _modbus_write_sub_request_rsp
.................... {
....................    unsigned int8 reference_type;
....................    unsigned int16 file_number;
....................    unsigned int16 record_number;
....................    unsigned int16 record_length;
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8];
.................... } modbus_write_sub_request_rsp;
.................... 
.................... /********************************************************************
.................... The following slave functions are defined in the MODBUS protocol.
.................... Please refer to http://www.modbus.org for the purpose of each of
.................... these.  All functions take the slaves address as their first
.................... parameter.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      coil_data          Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_coils_rsp(unsigned int8 address, unsigned int8 byte_count, unsigned int8* coil_data);
.................... 
.................... /*
.................... read_discrete_input_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_discrete_input_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                     unsigned int8 *input_data);
.................... 
.................... /*
.................... read_holding_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      reg_data           Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_holding_registers_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                         unsigned int16 *reg_data);
.................... 
.................... /*
.................... read_input_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_input_registers_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                         unsigned int16 *input_data);
.................... 
.................... /*
.................... write_single_coil_rsp
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Echo of output address received
....................            int16      output_value       Echo of output value received
.................... Output:    void
.................... */
.................... void modbus_write_single_coil_rsp(unsigned int8 address, unsigned int16 output_address,
....................                                     unsigned int16 output_value);
.................... 
.................... /*
.................... write_single_register_rsp
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Echo of register address received
....................            int16      reg_value          Echo of register value received
.................... Output:    void
.................... */
.................... void modbus_write_single_register_rsp(unsigned int8 address, unsigned int16 reg_address,
....................                                         unsigned int16 reg_value);
.................... 
.................... /*
.................... read_exception_status_rsp
.................... Input:     int8       address            Slave Address
.................... Output:    void
.................... */
.................... void modbus_read_exception_status_rsp(unsigned int8 address, unsigned int8 data);
.................... 
.................... /*
.................... diagnostics_rsp
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Echo of sub function received
....................            int16      data               Echo of data received
.................... Output:    void
.................... */
.................... void modbus_diagnostics_rsp(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data);
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_counter_rsp(unsigned int8 address, unsigned int16 status,
....................                                         unsigned int16 event_count);
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
....................            int16      message_count      Count of messages
....................            int8*      events             Pointer to event data
....................            int8       events_len         Length of event data in bytes
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_log_rsp(unsigned int8 address, unsigned int16 status,
....................                                     unsigned int16 event_count, unsigned int16 message_count,
....................                                     unsigned int8 *events, unsigned int8 events_len);
.................... 
.................... /*
.................... write_multiple_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of coils written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_coils_rsp(unsigned int8 address, unsigned int16 start_address,
....................                                         unsigned int16 quantity);
.................... 
.................... /*
.................... write_multiple_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of registers written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_registers_rsp(unsigned int8 address, unsigned int16 start_address,
....................                                             unsigned int16 quantity);
.................... 
.................... /*
.................... report_slave_id_rsp
.................... Input:     int8       address            Slave Address
....................            int8       slave_id           Slave Address
....................            int8       run_status         Are we running?
....................            int8*      data               Pointer to an array holding the data
....................            int8       data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_report_slave_id_rsp(unsigned int8 address, unsigned int8 slave_id, unsigned int1 run_status,
....................                               unsigned int8 *data, unsigned int8 data_len);
.................... 
.................... /*
.................... read_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Number of bytes to send
....................            read_sub_request_rsp*    request            Structure holding record/data information
.................... Output:    void
.................... */
.................... void modbus_read_file_record_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                     modbus_read_sub_request_rsp *request);
.................... 
.................... /*
.................... write_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Echo of number of bytes sent
....................            write_sub_request_rsp*   request            Echo of Structure holding record information
.................... Output:    void
.................... */
.................... void modbus_write_file_record_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                     modbus_write_sub_request_rsp *request);
.................... 
.................... /*
.................... mask_write_register_rsp
.................... Input:     int8        address            Slave Address
....................            int16       reference_address  Echo of reference address
....................            int16       AND_mask           Echo of AND mask
....................            int16       OR_mask            Echo or OR mask
.................... Output:    void
.................... */
.................... void modbus_mask_write_register_rsp(unsigned int8 address, unsigned int16 reference_address,
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask);
.................... 
.................... /*
.................... read_write_multiple_registers_rsp
.................... Input:     int8        address            Slave Address
....................            int16*      data               Pointer to an array of data
....................            int8        data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_read_write_multiple_registers_rsp(unsigned int8 address, unsigned int8 data_len,
....................                                                 unsigned int16 *data);
.................... 
.................... /*
.................... read_FIFO_queue_rsp
.................... Input:     int8        address            Slave Address
....................            int16       FIFO_len           Length of FIFO in bytes
....................            int16*      data               Pointer to an array of data
.................... Output:    void
.................... */
.................... void modbus_read_FIFO_queue_rsp(unsigned int8 address, unsigned int16 FIFO_len, unsigned int16 *data);
.................... 
.................... void modbus_exception_rsp(unsigned int8 address, unsigned int16 func, exception error);
.................... #endif //MODBUS_TYPE
.................... 
.................... #endif //MODBUS_APP_LAYER_H
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... //// Shared Api                                                                       ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // Purpose:    Initialize RS485 communication. Call this before
.................... //             using any other RS485 functions.
.................... // Inputs:     None
.................... // Outputs:    None
.................... void modbus_init()
.................... {
....................    output_low(MODBUS_SERIAL_ENABLE_PIN);
*
0436:  BCF    00.0
.................... 
....................    RCV_ON();
0438:  RCALL  0418
.................... 
....................    #if defined(__PCD__)
....................       enable_interrupts(INTR_GLOBAL);
....................    #else
....................       enable_interrupts(GLOBAL);
043A:  MOVLW  C0
043C:  IORWF  FF2,F
....................    #endif
043E:  GOTO   0AB6 (RETURN)
.................... }
.................... 
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer
.................... // Inputs:     None
.................... // Outputs:    TRUE if a message was received
.................... //             FALSE if no message is available
.................... // Note:       Data will be filled in at the modbus_rx struct:
.................... int1 modbus_kbhit()
.................... {
....................    #if(MODBUS_SERIAL_TYPE == MODBUS_RTU)
....................    modbus_check_timeout();
*
0772:  BRA    0754
....................    #endif
.................... 
....................    if(!modbus_serial_new)
0774:  BTFSC  1A.0
0776:  BRA    0780
....................      return FALSE;
0778:  MOVLW  00
077A:  MOVWF  01
077C:  BRA    0792
077E:  BRA    078C
....................    else if(modbus_rx.func & 0x80)           //did we receive an error?
0780:  BTFSS  1D.7
0782:  BRA    078C
....................    {
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true
0784:  MOVFF  1F,1E
....................       modbus_rx.len = 1;
0788:  MOVLW  01
078A:  MOVWF  1C
....................    }
....................    modbus_serial_new=FALSE;
078C:  BCF    1A.0
....................    return TRUE;
078E:  MOVLW  01
0790:  MOVWF  01
0792:  RETURN 0
.................... }
.................... 
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER)
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... //// Master API                                                                       ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... /********************************************************************
.................... The following functions are defined in the MODBUS protocol.  Please
.................... refer to http://www.modbus.org for the purpose of each of these.
.................... All functions take the slaves address as their first parameter.
.................... Each function returns the exception code received from the response.
.................... The function will return 0 if there were no errors in transmission.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_COILS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_discrete_input
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_discrete_input(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_holding_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_holding_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS);
*
0886:  MOVFF  7C,81
088A:  MOVLW  03
088C:  MOVWF  x82
088E:  RCALL  0688
.................... 
....................    modbus_serial_putc(make8(start_address,1));
0890:  MOVFF  7E,83
0894:  RCALL  0666
....................    modbus_serial_putc(make8(start_address,0));
0896:  MOVFF  7D,83
089A:  RCALL  0666
.................... 
....................    modbus_serial_putc(make8(quantity,1));
089C:  MOVFF  80,83
08A0:  RCALL  0666
....................    modbus_serial_putc(make8(quantity,0));
08A2:  MOVFF  7F,83
08A6:  RCALL  0666
.................... 
....................    modbus_serial_send_stop();
08A8:  RCALL  06A8
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
08AA:  BCF    1A.1
08AC:  MOVF   7C,F
08AE:  BZ    08EE
08B0:  RCALL  0772
08B2:  MOVF   01,F
08B4:  BNZ   08DA
08B6:  MOVLW  FF
08B8:  ADDWF  61,F
08BA:  BTFSS  FD8.0
08BC:  ADDWF  62,F
08BE:  BTFSS  FD8.0
08C0:  ADDWF  63,F
08C2:  BTFSS  FD8.0
08C4:  ADDWF  64,F
08C6:  MOVF   61,F
08C8:  BNZ   08D6
08CA:  MOVF   62,F
08CC:  BNZ   08D6
08CE:  MOVF   63,F
08D0:  BNZ   08D6
08D2:  MOVF   64,F
08D4:  BZ    08DA
08D6:  BRA    08D8
08D8:  BRA    08B0
08DA:  MOVF   61,F
08DC:  BNZ   08EE
08DE:  MOVF   62,F
08E0:  BNZ   08EE
08E2:  MOVF   63,F
08E4:  BNZ   08EE
08E6:  MOVF   64,F
08E8:  BNZ   08EE
08EA:  MOVLW  0C
08EC:  MOVWF  1E
08EE:  CLRF   64
08F0:  CLRF   63
08F2:  MOVLW  27
08F4:  MOVWF  62
08F6:  MOVLW  10
08F8:  MOVWF  61
.................... 
....................    return modbus_rx.error;
08FA:  MOVFF  1E,01
08FE:  GOTO   091C (RETURN)
.................... }
.................... 
.................... /*
.................... read_input_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_input_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_single_coil
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Address to write into
....................            int1       on                 true for on, false for off
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_single_coil(unsigned int8 address, unsigned int16 output_address, int1 on)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL);
.................... 
....................    modbus_serial_putc(make8(output_address,1));
....................    modbus_serial_putc(make8(output_address,0));
.................... 
....................    if(on)
....................        modbus_serial_putc(0xFF);
....................    else
....................        modbus_serial_putc(0x00);
.................... 
....................    modbus_serial_putc(0x00);
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_single_register
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Address to write into
....................            int16      reg_value          Value to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_single_register(unsigned int8 address, unsigned int16 reg_address, unsigned int16 reg_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER);
*
0794:  MOVFF  7C,81
0798:  MOVLW  06
079A:  MOVWF  x82
079C:  RCALL  0688
.................... 
....................    modbus_serial_putc(make8(reg_address,1));
079E:  MOVFF  7E,83
07A2:  RCALL  0666
....................    modbus_serial_putc(make8(reg_address,0));
07A4:  MOVFF  7D,83
07A8:  RCALL  0666
.................... 
....................    modbus_serial_putc(make8(reg_value,1));
07AA:  MOVFF  80,83
07AE:  RCALL  0666
....................    modbus_serial_putc(make8(reg_value,0));
07B0:  MOVFF  7F,83
07B4:  RCALL  0666
.................... 
....................    modbus_serial_send_stop();
07B6:  RCALL  06A8
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
07B8:  BCF    1A.1
07BA:  MOVF   7C,F
07BC:  BZ    07FC
07BE:  RCALL  0772
07C0:  MOVF   01,F
07C2:  BNZ   07E8
07C4:  MOVLW  FF
07C6:  ADDWF  61,F
07C8:  BTFSS  FD8.0
07CA:  ADDWF  62,F
07CC:  BTFSS  FD8.0
07CE:  ADDWF  63,F
07D0:  BTFSS  FD8.0
07D2:  ADDWF  64,F
07D4:  MOVF   61,F
07D6:  BNZ   07E4
07D8:  MOVF   62,F
07DA:  BNZ   07E4
07DC:  MOVF   63,F
07DE:  BNZ   07E4
07E0:  MOVF   64,F
07E2:  BZ    07E8
07E4:  BRA    07E6
07E6:  BRA    07BE
07E8:  MOVF   61,F
07EA:  BNZ   07FC
07EC:  MOVF   62,F
07EE:  BNZ   07FC
07F0:  MOVF   63,F
07F2:  BNZ   07FC
07F4:  MOVF   64,F
07F6:  BNZ   07FC
07F8:  MOVLW  0C
07FA:  MOVWF  1E
07FC:  CLRF   64
07FE:  CLRF   63
0800:  MOVLW  27
0802:  MOVWF  62
0804:  MOVLW  10
0806:  MOVWF  61
.................... 
....................    return modbus_rx.error;
0808:  MOVFF  1E,01
080C:  GOTO   082A (RETURN)
.................... }
.................... 
.................... /*
.................... read_exception_status
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_exception_status(unsigned int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... diagnostics
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Subfunction to send
....................            int16      data               Data to send, changes based on subfunction
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_diagnostics(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS);
.................... 
....................    modbus_serial_putc(make8(sub_func,1));
....................    modbus_serial_putc(make8(sub_func,0));
.................... 
....................    modbus_serial_putc(make8(data,1));
....................    modbus_serial_putc(make8(data,0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... get_comm_event_couter
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_get_comm_event_counter(unsigned int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... get_comm_event_log
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_get_comm_event_log(unsigned int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_multiple_coils
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start at
....................            int16      quantity           Amount of coils to write to
....................            int1*      values             A pointer to an array holding the values to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_multiple_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity,
....................                            unsigned int8 *values)
.................... {
....................    unsigned int8 i,count;
.................... 
....................    count = (unsigned int8)((quantity/8));
.................... 
....................    if(quantity%8)
....................       count++;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_putc(count);
.................... 
....................    for(i=0; i < count; ++i)
....................       modbus_serial_putc(values[i]);
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_multiple_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start at
....................            int16      quantity           Amount of coils to write to
....................            int16*     values             A pointer to an array holding the data to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_multiple_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity,
....................                            unsigned int16 *values)
.................... {
....................    unsigned int8 i,count;
.................... 
....................    count = quantity*2;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_putc(count);
.................... 
....................    for(i=0; i < quantity; ++i)
....................    {
....................       modbus_serial_putc(make8(values[i],1));
....................       modbus_serial_putc(make8(values[i],0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... report_slave_id
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_report_slave_id(unsigned int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_file_record
.................... Input:     int8                address            Slave Address
....................            int8                byte_count         Number of bytes to read
....................            read_sub_request*   request            Structure holding record information
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_read_file_record(unsigned int8 address, unsigned int8 byte_count,
....................                             modbus_read_sub_request *request)
.................... {
....................    unsigned int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < (byte_count/7); i+=7)
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_file_record
.................... Input:     int8                address            Slave Address
....................            int8                byte_count         Number of bytes to read
....................            read_sub_request*   request            Structure holding record/data information
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_write_file_record(unsigned int8 address, unsigned int8 byte_count,
....................                             modbus_write_sub_request *request)
.................... {
....................    unsigned int8 i, j=0;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; i+=(7+(j*2)))
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
.................... 
....................       for(j=0; (j < request->record_length) &&
....................             (j < MODBUS_SERIAL_RX_BUFFER_SIZE-8); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... mask_write_register
.................... Input:     int8       address            Slave Address
....................            int16      reference_address  Address to mask
....................            int16      AND_mask           A mask to AND with the data at reference_address
....................            int16      OR_mask            A mask to OR with the data at reference_address
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_mask_write_register(unsigned int8 address, unsigned int16 reference_address,
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask)
.................... {
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reference_address,1));
....................    modbus_serial_putc(make8(reference_address,0));
.................... 
....................    modbus_serial_putc(make8(AND_mask,1));
....................    modbus_serial_putc(make8(AND_mask,0));
.................... 
....................    modbus_serial_putc(make8(OR_mask, 1));
....................    modbus_serial_putc(make8(OR_mask, 0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_write_multiple_registers
.................... Input:     int8       address                Slave Address
....................            int16      read_start             Address to start reading
....................            int16      read_quantity          Amount of registers to read
....................            int16      write_start            Address to start writing
....................            int16      write_quantity         Amount of registers to write
....................            int16*     write_registers_value  Pointer to an aray us to write
.................... Output:    exception                         0 if no error, else the exception
.................... */
.................... exception modbus_read_write_multiple_registers(unsigned int8 address, unsigned int16 read_start,
....................                                     unsigned int16 read_quantity, unsigned int16 write_start,
....................                                     unsigned int16 write_quantity,
....................                                     unsigned int16 *write_registers_value)
.................... {
....................    unsigned int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(read_start,1));
....................    modbus_serial_putc(make8(read_start,0));
.................... 
....................    modbus_serial_putc(make8(read_quantity,1));
....................    modbus_serial_putc(make8(read_quantity,0));
.................... 
....................    modbus_serial_putc(make8(write_start, 1));
....................    modbus_serial_putc(make8(write_start, 0));
.................... 
....................    modbus_serial_putc(make8(write_quantity, 1));
....................    modbus_serial_putc(make8(write_quantity, 0));
.................... 
....................    modbus_serial_putc((unsigned int8)(2*write_quantity));
.................... 
....................    for(i=0; i < write_quantity ; i+=2)
....................    {
....................       modbus_serial_putc(make8(write_registers_value[i], 1));
....................       modbus_serial_putc(make8(write_registers_value[i+1], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_FIFO_queue
.................... Input:     int8       address           Slave Address
....................            int16      FIFO_address      FIFO address
.................... Output:    exception                    0 if no error, else the exception
.................... */
.................... exception modbus_read_FIFO_queue(unsigned int8 address, unsigned int16 FIFO_address)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE);
.................... 
....................    modbus_serial_putc(make8(FIFO_address, 1));
....................    modbus_serial_putc(make8(FIFO_address, 0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... #else
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... //// Slave API                                                                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... /********************************************************************
.................... The following slave functions are defined in the MODBUS protocol.
.................... Please refer to http://www.modbus.org for the purpose of each of
.................... these.  All functions take the slaves address as their first
.................... parameter.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      coil_data          Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_coils_rsp(unsigned int8 address, unsigned int8 byte_count, unsigned int8* coil_data)
.................... {
....................    unsigned int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_COILS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*coil_data);
....................       coil_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_discrete_input_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_discrete_input_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                     unsigned int8 *input_data)
.................... {
....................    unsigned int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*input_data);
....................       input_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_holding_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      reg_data           Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_holding_registers_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                         unsigned int16 *reg_data)
.................... {
....................    unsigned int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; i+=2)
....................    {
....................       modbus_serial_putc(make8(*reg_data,1));
....................       modbus_serial_putc(make8(*reg_data,0));
....................       reg_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_input_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_input_registers_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                         unsigned int16 *input_data)
.................... {
....................    unsigned int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; i+=2)
....................    {
....................       modbus_serial_putc(make8(*input_data,1));
....................       modbus_serial_putc(make8(*input_data,0));
....................       input_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_single_coil_rsp
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Echo of output address received
....................            int16      output_value       Echo of output value received
.................... Output:    void
.................... */
.................... void modbus_write_single_coil_rsp(unsigned int8 address, unsigned int16 output_address,
....................                                     unsigned int16 output_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL);
.................... 
....................    modbus_serial_putc(make8(output_address,1));
....................    modbus_serial_putc(make8(output_address,0));
.................... 
....................    modbus_serial_putc(make8(output_value,1));
....................    modbus_serial_putc(make8(output_value,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_single_register_rsp
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Echo of register address received
....................            int16      reg_value          Echo of register value received
.................... Output:    void
.................... */
.................... void modbus_write_single_register_rsp(unsigned int8 address, unsigned int16 reg_address,
....................                                         unsigned int16 reg_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reg_address,1));
....................    modbus_serial_putc(make8(reg_address,0));
.................... 
....................    modbus_serial_putc(make8(reg_value,1));
....................    modbus_serial_putc(make8(reg_value,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_exception_status_rsp
.................... Input:     int8       address            Slave Address
.................... Output:    void
.................... */
.................... void modbus_read_exception_status_rsp(unsigned int8 address, unsigned int8 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS);
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... diagnostics_rsp
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Echo of sub function received
....................            int16      data               Echo of data received
.................... Output:    void
.................... */
.................... void modbus_diagnostics_rsp(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS);
.................... 
....................    modbus_serial_putc(make8(sub_func,1));
....................    modbus_serial_putc(make8(sub_func,0));
.................... 
....................    modbus_serial_putc(make8(data,1));
....................    modbus_serial_putc(make8(data,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_counter_rsp(unsigned int8 address, unsigned int16 status,
....................                                         unsigned int16 event_count)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER);
.................... 
....................    modbus_serial_putc(make8(status, 1));
....................    modbus_serial_putc(make8(status, 0));
.................... 
....................    modbus_serial_putc(make8(event_count, 1));
....................    modbus_serial_putc(make8(event_count, 0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
....................            int16      message_count      Count of messages
....................            int8*      events             Pointer to event data
....................            int8       events_len         Length of event data in bytes
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_log_rsp(unsigned int8 address, unsigned int16 status,
....................                                     unsigned int16 event_count, unsigned int16 message_count,
....................                                     unsigned int8 *events, unsigned int8 events_len)
.................... {
....................    unsigned int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG);
.................... 
....................    modbus_serial_putc(events_len+6);
.................... 
....................    modbus_serial_putc(make8(status, 1));
....................    modbus_serial_putc(make8(status, 0));
.................... 
....................    modbus_serial_putc(make8(event_count, 1));
....................    modbus_serial_putc(make8(event_count, 0));
.................... 
....................    modbus_serial_putc(make8(message_count, 1));
....................    modbus_serial_putc(make8(message_count, 0));
.................... 
....................    for(i=0; i < events_len; ++i)
....................    {
....................       modbus_serial_putc(*events);
....................       events++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_multiple_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of coils written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_coils_rsp(unsigned int8 address, unsigned int16 start_address,
....................                                         unsigned int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_multiple_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of registers written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_registers_rsp(unsigned int8 address, unsigned int16 start_address,
....................                                             unsigned int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... report_slave_id_rsp
.................... Input:     int8       address            Slave Address
....................            int8       slave_id           Slave Address
....................            int8       run_status         Are we running?
....................            int8*      data               Pointer to an array holding the data
....................            int8       data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_report_slave_id_rsp(unsigned int8 address, unsigned int8 slave_id, unsigned int1 run_status,
....................                               unsigned int8 *data, unsigned int8 data_len)
.................... {
....................    unsigned int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID);
.................... 
....................    modbus_serial_putc(data_len+2);
....................    modbus_serial_putc(slave_id);
.................... 
....................    if(run_status)
....................     modbus_serial_putc(0xFF);
....................    else
....................     modbus_serial_putc(0x00);
.................... 
....................    for(i=0; i < data_len; ++i)
....................    {
....................       modbus_serial_putc(*data);
....................       data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Number of bytes to send
....................            read_sub_request_rsp*    request            Structure holding record/data information
.................... Output:    void
.................... */
.................... void modbus_read_file_record_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                     modbus_read_sub_request_rsp *request)
.................... {
....................    unsigned int8 i=0,j;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    while(i < byte_count);
....................    {
....................       modbus_serial_putc(request->record_length);
....................       modbus_serial_putc(request->reference_type);
.................... 
....................       for(j=0; (j < request->record_length); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
.................... 
....................       i += (request->record_length)+1;
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Echo of number of bytes sent
....................            write_sub_request_rsp*   request            Echo of Structure holding record information
.................... Output:    void
.................... */
.................... void modbus_write_file_record_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                     modbus_write_sub_request_rsp *request)
.................... {
....................    unsigned int8 i, j=0;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; i+=(7+(j*2)))
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
.................... 
....................       for(j=0; (j < request->record_length); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... mask_write_register_rsp
.................... Input:     int8        address            Slave Address
....................            int16       reference_address  Echo of reference address
....................            int16       AND_mask           Echo of AND mask
....................            int16       OR_mask            Echo or OR mask
.................... Output:    void
.................... */
.................... void modbus_mask_write_register_rsp(unsigned int8 address, unsigned int16 reference_address,
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask)
.................... {
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reference_address,1));
....................    modbus_serial_putc(make8(reference_address,0));
.................... 
....................    modbus_serial_putc(make8(AND_mask,1));
....................    modbus_serial_putc(make8(AND_mask,0));
.................... 
....................    modbus_serial_putc(make8(OR_mask, 1));
....................    modbus_serial_putc(make8(OR_mask, 0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_write_multiple_registers_rsp
.................... Input:     int8        address            Slave Address
....................            int16*      data               Pointer to an array of data
....................            int8        data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_read_write_multiple_registers_rsp(unsigned int8 address, unsigned int8 data_len,
....................                                                 unsigned int16 *data)
.................... {
....................    unsigned int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(data_len*2);
.................... 
....................    for(i=0; i < data_len*2; i+=2)
....................    {
....................       modbus_serial_putc(make8(data[i], 1));
....................       modbus_serial_putc(make8(data[i], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_FIFO_queue_rsp
.................... Input:     int8        address            Slave Address
....................            int16       FIFO_len           Length of FIFO in bytes
....................            int16*      data               Pointer to an array of data
.................... Output:    void
.................... */
.................... void modbus_read_FIFO_queue_rsp(unsigned int8 address, unsigned int16 FIFO_len, unsigned int16 *data)
.................... {
....................    unsigned int8 i;
....................    unsigned int16 byte_count;
.................... 
....................    byte_count = ((FIFO_len*2)+2);
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE);
.................... 
....................    modbus_serial_putc(make8(byte_count, 1));
....................    modbus_serial_putc(make8(byte_count, 0));
.................... 
....................    modbus_serial_putc(make8(FIFO_len, 1));
....................    modbus_serial_putc(make8(FIFO_len, 0));
.................... 
....................    for(i=0; i < FIFO_len; i+=2)
....................    {
....................       modbus_serial_putc(make8(data[i], 1));
....................       modbus_serial_putc(make8(data[i], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_FIFO_queue_rsp
.................... Input:     int8        address            Slave Address
....................            int16       func               function to respond to
....................            exception   error              exception response to send
.................... Output:    void
.................... */
.................... void modbus_exception_rsp(unsigned int8 address, unsigned int16 func, exception error)
.................... {
....................    modbus_serial_send_start(address, func|0x80);
....................    modbus_serial_putc(error);
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... #endif
.................... #endif //MODBUS_APP_LAYER_C
.................... 
.................... #endif
.................... 
.................... 
.................... #include "flex_lcd420.c" //using 4x20 LCD
.................... // Flex_LCD420.c
.................... 
.................... #define LCD_DB4   PIN_B4
.................... #define LCD_DB5   PIN_B5
.................... #define LCD_DB6   PIN_B6
.................... #define LCD_DB7   PIN_B7
.................... 
.................... #define LCD_RS    PIN_B3
.................... #define LCD_RW    PIN_B2
.................... #define LCD_E     PIN_B1
.................... 
.................... #define USE_RW_PIN   1     
.................... 
.................... 
.................... // These are the line addresses for most 4x20 LCDs.
.................... #define LCD_LINE_1_ADDRESS 0x00
.................... #define LCD_LINE_2_ADDRESS 0x40
.................... #define LCD_LINE_3_ADDRESS 0x14
.................... #define LCD_LINE_4_ADDRESS 0x54
.................... 
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more)
.................... 
.................... int8 lcd_line;
.................... 
.................... int8 const LCD_INIT_STRING[4] =
.................... {
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots
....................  0xc,                     // Display on
....................  1,                       // Clear display
....................  6                        // Increment cursor
....................  };
....................                              
.................... 
.................... //-------------------------------------
.................... void lcd_send_nibble(int8 nibble)
.................... {
.................... // Note:  !! converts an integer expression
.................... // to a boolean (1 or 0).
....................  output_bit(LCD_DB4, !!(nibble & 1));
*
0468:  BTFSC  x87.0
046A:  BRA    0470
046C:  BCF    F8A.4
046E:  BRA    0472
0470:  BSF    F8A.4
0472:  BCF    F93.4
....................  output_bit(LCD_DB5, !!(nibble & 2)); 
0474:  BTFSC  x87.1
0476:  BRA    047C
0478:  BCF    F8A.5
047A:  BRA    047E
047C:  BSF    F8A.5
047E:  BCF    F93.5
....................  output_bit(LCD_DB6, !!(nibble & 4));   
0480:  BTFSC  x87.2
0482:  BRA    0488
0484:  BCF    F8A.6
0486:  BRA    048A
0488:  BSF    F8A.6
048A:  BCF    F93.6
....................  output_bit(LCD_DB7, !!(nibble & 8));   
048C:  BTFSC  x87.3
048E:  BRA    0494
0490:  BCF    F8A.7
0492:  BRA    0496
0494:  BSF    F8A.7
0496:  BCF    F93.7
.................... 
....................  delay_cycles(1);
0498:  NOP   
....................  output_high(LCD_E);
049A:  BCF    F93.1
049C:  BSF    F8A.1
....................  delay_us(2);
049E:  BRA    04A0
04A0:  BRA    04A2
....................  output_low(LCD_E);
04A2:  BCF    F93.1
04A4:  BCF    F8A.1
04A6:  RETURN 0
.................... }
.................... 
.................... //-----------------------------------
.................... // This sub-routine is only called by lcd_read_byte().
.................... // It's not a stand-alone routine.  For example, the
.................... // R/W signal is set high by lcd_read_byte() before
.................... // this routine is called.     
.................... 
.................... #ifdef USE_RW_PIN
.................... int8 lcd_read_nibble(void)
.................... {
.................... int8 retval;
.................... // Create bit variables so that we can easily set
.................... // individual bits in the retval variable.
.................... #bit retval_0 = retval.0
.................... #bit retval_1 = retval.1
.................... #bit retval_2 = retval.2
.................... #bit retval_3 = retval.3
.................... 
.................... retval = 0;
04A8:  CLRF   x88
....................    
.................... output_high(LCD_E);
04AA:  BCF    F93.1
04AC:  BSF    F8A.1
.................... delay_us(1);
04AE:  BRA    04B0
.................... 
.................... retval_0 = input(LCD_DB4);
04B0:  BSF    F93.4
04B2:  BCF    x88.0
04B4:  BTFSC  F81.4
04B6:  BSF    x88.0
.................... retval_1 = input(LCD_DB5);
04B8:  BSF    F93.5
04BA:  BCF    x88.1
04BC:  BTFSC  F81.5
04BE:  BSF    x88.1
.................... retval_2 = input(LCD_DB6);
04C0:  BSF    F93.6
04C2:  BCF    x88.2
04C4:  BTFSC  F81.6
04C6:  BSF    x88.2
.................... retval_3 = input(LCD_DB7);
04C8:  BSF    F93.7
04CA:  BCF    x88.3
04CC:  BTFSC  F81.7
04CE:  BSF    x88.3
....................  
.................... output_low(LCD_E);
04D0:  BCF    F93.1
04D2:  BCF    F8A.1
.................... delay_us(1);
04D4:  BRA    04D6
....................    
.................... return(retval);   
04D6:  MOVFF  88,01
04DA:  RETURN 0
.................... }   
.................... #endif
.................... 
.................... //---------------------------------------
.................... // Read a byte from the LCD and return it.
.................... 
.................... #ifdef USE_RW_PIN
.................... int8 lcd_read_byte(void)
.................... {
.................... int8 low;
.................... int8 high;
.................... 
.................... output_high(LCD_RW);
04DC:  BCF    F93.2
04DE:  BSF    F8A.2
.................... delay_cycles(1);
04E0:  NOP   
.................... 
.................... high = lcd_read_nibble();
04E2:  RCALL  04A8
04E4:  MOVFF  01,87
.................... 
.................... low = lcd_read_nibble();
04E8:  RCALL  04A8
04EA:  MOVFF  01,86
.................... 
.................... return( (high<<4) | low);
04EE:  SWAPF  x87,W
04F0:  MOVWF  00
04F2:  MOVLW  F0
04F4:  ANDWF  00,F
04F6:  MOVF   00,W
04F8:  IORWF  x86,W
04FA:  MOVWF  01
04FC:  GOTO   0506 (RETURN)
.................... }
.................... #endif
.................... 
.................... //----------------------------------------
.................... // Send a byte to the LCD.
.................... void lcd_send_byte(int8 address, int8 n)
.................... {
.................... output_low(LCD_RS);
0500:  BCF    F93.3
0502:  BCF    F8A.3
.................... 
.................... #ifdef USE_RW_PIN
.................... while(bit_test(lcd_read_byte(),7)) ;
0504:  BRA    04DC
0506:  MOVFF  01,86
050A:  BTFSC  01.7
050C:  BRA    0504
.................... #else
.................... delay_us(60); 
.................... #endif
.................... 
.................... if(address)
050E:  MOVF   x84,F
0510:  BZ    0518
....................    output_high(LCD_RS);
0512:  BCF    F93.3
0514:  BSF    F8A.3
0516:  BRA    051C
.................... else
....................    output_low(LCD_RS);
0518:  BCF    F93.3
051A:  BCF    F8A.3
....................      
....................  delay_cycles(1);
051C:  NOP   
.................... 
.................... #ifdef USE_RW_PIN
.................... output_low(LCD_RW);
051E:  BCF    F93.2
0520:  BCF    F8A.2
.................... delay_cycles(1);
0522:  NOP   
.................... #endif
.................... 
.................... output_low(LCD_E);
0524:  BCF    F93.1
0526:  BCF    F8A.1
.................... 
.................... lcd_send_nibble(n >> 4);
0528:  SWAPF  x85,W
052A:  MOVWF  x86
052C:  MOVLW  0F
052E:  ANDWF  x86,F
0530:  MOVFF  86,87
0534:  RCALL  0468
.................... lcd_send_nibble(n & 0xf);
0536:  MOVF   x85,W
0538:  ANDLW  0F
053A:  MOVWF  x86
053C:  MOVWF  x87
053E:  RCALL  0468
0540:  RETURN 0
.................... }
.................... //----------------------------
.................... 
.................... void lcd_init(void)
.................... {
.................... int8 i;
.................... 
.................... lcd_line = 1;
0542:  MOVLW  01
0544:  MOVWF  68
.................... 
.................... output_low(LCD_RS);
0546:  BCF    F93.3
0548:  BCF    F8A.3
.................... 
.................... #ifdef USE_RW_PIN
.................... output_low(LCD_RW);
054A:  BCF    F93.2
054C:  BCF    F8A.2
.................... #endif
.................... 
.................... output_low(LCD_E);
054E:  BCF    F93.1
0550:  BCF    F8A.1
.................... 
.................... // Some LCDs require 15 ms minimum delay after
.................... // power-up.  Others require 30 ms.  I'm going
.................... // to set it to 35 ms, so it should work with
.................... // all of them.
.................... delay_ms(35);         
0552:  MOVLW  23
0554:  MOVWF  x80
0556:  RCALL  0442
.................... 
.................... for(i=0 ;i < 3; i++)
0558:  CLRF   74
055A:  MOVF   74,W
055C:  SUBLW  02
055E:  BNC   0570
....................    {
....................     lcd_send_nibble(0x03);
0560:  MOVLW  03
0562:  MOVWF  x87
0564:  RCALL  0468
....................     delay_ms(5);
0566:  MOVLW  05
0568:  MOVWF  x80
056A:  RCALL  0442
056C:  INCF   74,F
056E:  BRA    055A
....................    }
.................... 
.................... lcd_send_nibble(0x02);
0570:  MOVLW  02
0572:  MOVWF  x87
0574:  RCALL  0468
.................... 
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++)
0576:  CLRF   74
0578:  MOVF   74,W
057A:  SUBLW  03
057C:  BNC   0590
....................    {
....................     lcd_send_byte(0, LCD_INIT_STRING[i]);
057E:  CLRF   03
0580:  MOVF   74,W
0582:  RCALL  02DA
0584:  MOVWF  75
0586:  CLRF   x84
0588:  MOVWF  x85
058A:  RCALL  0500
....................    
....................     // If the R/W signal is not used, then
....................     // the busy bit can't be polled.  One of
....................     // the init commands takes longer than
....................     // the hard-coded delay of 50 us, so in
....................     // that case, lets just do a 5 ms delay
....................     // after all four of them.
....................     #ifndef USE_RW_PIN
058C:  INCF   74,F
058E:  BRA    0578
....................     delay_ms(5);
....................     #endif
....................    }
0590:  GOTO   0AB8 (RETURN)
.................... 
.................... }
.................... 
.................... //----------------------------
.................... 
.................... void lcd_gotoxy(int8 x, int8 y)
.................... {
.................... int8 address;
.................... 
.................... 
.................... switch(y)
0594:  MOVF   x81,W
0596:  XORLW  01
0598:  BZ    05A8
059A:  XORLW  03
059C:  BZ    05AC
059E:  XORLW  01
05A0:  BZ    05B2
05A2:  XORLW  07
05A4:  BZ    05B8
05A6:  BRA    05BE
....................   {
....................    case 1:
....................      address = LCD_LINE_1_ADDRESS;
05A8:  CLRF   x82
....................      break;
05AA:  BRA    05C0
.................... 
....................    case 2:
....................      address = LCD_LINE_2_ADDRESS;
05AC:  MOVLW  40
05AE:  MOVWF  x82
....................      break;
05B0:  BRA    05C0
.................... 
....................    case 3:
....................      address = LCD_LINE_3_ADDRESS;
05B2:  MOVLW  14
05B4:  MOVWF  x82
....................      break;
05B6:  BRA    05C0
.................... 
....................    case 4:
....................      address = LCD_LINE_4_ADDRESS;
05B8:  MOVLW  54
05BA:  MOVWF  x82
....................      break;
05BC:  BRA    05C0
.................... 
....................    default:
....................      address = LCD_LINE_1_ADDRESS;
05BE:  CLRF   x82
....................      break;
....................      
....................   }
.................... 
.................... address += x-1;
05C0:  MOVLW  01
05C2:  SUBWF  x80,W
05C4:  ADDWF  x82,F
.................... lcd_send_byte(0, 0x80 | address);
05C6:  MOVF   x82,W
05C8:  IORLW  80
05CA:  MOVWF  x83
05CC:  CLRF   x84
05CE:  MOVWF  x85
05D0:  RCALL  0500
05D2:  RETURN 0
.................... }
.................... 
.................... //-----------------------------
.................... void lcd_putc(char c)
.................... {
....................  switch(c)
05D4:  MOVF   7F,W
05D6:  XORLW  0C
05D8:  BZ    05E4
05DA:  XORLW  06
05DC:  BZ    05F8
05DE:  XORLW  02
05E0:  BZ    0606
05E2:  BRA    0610
....................    {
....................     case '\f':
....................       lcd_send_byte(0,1);
05E4:  CLRF   x84
05E6:  MOVLW  01
05E8:  MOVWF  x85
05EA:  RCALL  0500
....................       lcd_line = 1;
05EC:  MOVLW  01
05EE:  MOVWF  68
....................       delay_ms(2);
05F0:  MOVLW  02
05F2:  MOVWF  x80
05F4:  RCALL  0442
....................       break;
05F6:  BRA    061A
....................    
....................     case '\n':
....................        lcd_gotoxy(1, ++lcd_line);
05F8:  INCF   68,F
05FA:  MOVLW  01
05FC:  MOVWF  x80
05FE:  MOVFF  68,81
0602:  RCALL  0594
....................        break;
0604:  BRA    061A
....................    
....................     case '\b':
....................        lcd_send_byte(0,0x10);
0606:  CLRF   x84
0608:  MOVLW  10
060A:  MOVWF  x85
060C:  RCALL  0500
....................        break;
060E:  BRA    061A
....................    
....................     default:
....................        lcd_send_byte(1,c);
0610:  MOVLW  01
0612:  MOVWF  x84
0614:  MOVFF  7F,85
0618:  RCALL  0500
....................        break;
....................    }
061A:  RETURN 0
.................... }
.................... 
.................... //------------------------------
.................... #ifdef USE_RW_PIN
.................... char lcd_getc(int8 x, int8 y)
.................... {
.................... char value;
.................... 
.................... lcd_gotoxy(x,y);
.................... 
.................... // Wait until busy flag is low.
.................... while(bit_test(lcd_read_byte(),7)); 
.................... 
.................... output_high(LCD_RS);
.................... value = lcd_read_byte();
.................... output_low(LCD_RS);
.................... 
.................... return(value);
.................... }
.................... #endif
.................... 
.................... 
.................... 
.................... unsigned int16 read_reg[3]; //readed reg values (default 3 reg)
.................... int8 d=0;
.................... 
.................... void read_all_holding(int16 start, int16 quantity) //read holding registers (start adress, quantity)
.................... {
....................    output_high(MODBUS_SERIAL_RX_ENABLE);
*
0902:  BCF    F95.2
0904:  BSF    F8C.2
....................    
....................    modbus_read_holding_registers(MODBUS_SLAVE_ADDRESS,start,quantity);
0906:  MOVLW  05
0908:  MOVWF  7C
090A:  MOVFF  75,7E
090E:  MOVFF  74,7D
0912:  MOVFF  77,80
0916:  MOVFF  76,7F
091A:  BRA    0886
....................    
....................    int count=0;
091C:  CLRF   78
....................      
....................    for(int i=1; i < (modbus_rx.len); i=i+2){ 
091E:  MOVLW  01
0920:  MOVWF  79
0922:  MOVF   1C,W
0924:  SUBWF  79,W
0926:  BC    0970
....................       
....................       unsigned int16 val;
....................       val=make16( modbus_rx.data[i], modbus_rx.data[i+1]);
0928:  CLRF   03
092A:  MOVF   79,W
092C:  ADDLW  1F
092E:  MOVWF  FE9
0930:  MOVLW  00
0932:  ADDWFC 03,W
0934:  MOVWF  FEA
0936:  MOVFF  FEF,7B
093A:  MOVLW  01
093C:  ADDWF  79,W
093E:  CLRF   03
0940:  ADDLW  1F
0942:  MOVWF  FE9
0944:  MOVLW  00
0946:  ADDWFC 03,W
0948:  MOVWF  FEA
094A:  MOVFF  FEF,7A
....................       read_reg[count]=val;
094E:  BCF    FD8.0
0950:  RLCF   78,W
0952:  CLRF   03
0954:  ADDLW  69
0956:  MOVWF  FE9
0958:  MOVLW  00
095A:  ADDWFC 03,W
095C:  MOVWF  FEA
095E:  MOVFF  7B,FEC
0962:  MOVF   FED,F
0964:  MOVFF  7A,FEF
....................       count++;
0968:  INCF   78,F
096A:  MOVLW  02
096C:  ADDWF  79,F
096E:  BRA    0922
....................    }
....................    
....................    output_low(MODBUS_SERIAL_RX_ENABLE);
0970:  BCF    F95.2
0972:  BCF    F8C.2
0974:  GOTO   0AEA (RETURN)
.................... }
.................... 
.................... 
.................... void write_reg(int16 address, unsigned int16 data) //write one register  (adress,data)
.................... {
....................    output_high(MODBUS_SERIAL_RX_ENABLE);
*
0810:  BCF    F95.2
0812:  BSF    F8C.2
....................    
....................    modbus_write_single_register(MODBUS_SLAVE_ADDRESS,address,data);
0814:  MOVLW  05
0816:  MOVWF  7C
0818:  MOVFF  75,7E
081C:  MOVFF  74,7D
0820:  MOVFF  77,80
0824:  MOVFF  76,7F
0828:  BRA    0794
....................    
....................    int count=0;
082A:  CLRF   78
....................      
....................    for(int i=1; i < (modbus_rx.len); i=i+2){ 
082C:  MOVLW  01
082E:  MOVWF  79
0830:  MOVF   1C,W
0832:  SUBWF  79,W
0834:  BC    087E
....................       
....................       unsigned int16 val;
....................       val=make16( modbus_rx.data[i], modbus_rx.data[i+1]);
0836:  CLRF   03
0838:  MOVF   79,W
083A:  ADDLW  1F
083C:  MOVWF  FE9
083E:  MOVLW  00
0840:  ADDWFC 03,W
0842:  MOVWF  FEA
0844:  MOVFF  FEF,7B
0848:  MOVLW  01
084A:  ADDWF  79,W
084C:  CLRF   03
084E:  ADDLW  1F
0850:  MOVWF  FE9
0852:  MOVLW  00
0854:  ADDWFC 03,W
0856:  MOVWF  FEA
0858:  MOVFF  FEF,7A
....................       read_reg[count]=val;
085C:  BCF    FD8.0
085E:  RLCF   78,W
0860:  CLRF   03
0862:  ADDLW  69
0864:  MOVWF  FE9
0866:  MOVLW  00
0868:  ADDWFC 03,W
086A:  MOVWF  FEA
086C:  MOVFF  7B,FEC
0870:  MOVF   FED,F
0872:  MOVFF  7A,FEF
....................       count++;
0876:  INCF   78,F
0878:  MOVLW  02
087A:  ADDWF  79,F
087C:  BRA    0830
....................    }
....................    
....................    output_low(MODBUS_SERIAL_RX_ENABLE);
087E:  BCF    F95.2
0880:  BCF    F8C.2
0882:  GOTO   0ADE (RETURN)
.................... }
.................... 
.................... 
.................... void write_multiple_reg(int16 start, int16 quantity, unsigned int16 reg_array) //write multiple registers  (start adress, quantity, data as array)
.................... {
....................    
....................    output_high(MODBUS_SERIAL_RX_ENABLE);
....................    
....................    modbus_write_multiple_registers(MODBUS_SLAVE_ADDRESS,start,quantity,reg_array);
....................    
....................    output_low(MODBUS_SERIAL_RX_ENABLE);
....................    
.................... }
.................... 
.................... 
.................... void main()
*
0A54:  CLRF   FF8
0A56:  BCF    FD0.7
0A58:  BSF    07.7
0A5A:  MOVLW  70
0A5C:  MOVWF  FD3
0A5E:  CLRF   F9B
0A60:  MOVF   FD3,W
0A62:  BCF    1A.0
0A64:  CLRF   5F
0A66:  BCF    FCD.0
0A68:  MOVLW  B5
0A6A:  MOVWF  FCD
0A6C:  CLRF   FCF
0A6E:  CLRF   FCE
0A70:  NOP   
0A72:  BCF    F9E.0
0A74:  BSF    F9D.0
0A76:  CLRF   60
0A78:  BCF    FB8.3
0A7A:  MOVLW  0C
0A7C:  MOVWF  FAF
0A7E:  MOVLW  E2
0A80:  MOVWF  FAC
0A82:  MOVLW  D0
0A84:  MOVWF  FAB
0A86:  NOP   
0A88:  NOP   
0A8A:  BCF    1A.1
0A8C:  CLRF   64
0A8E:  CLRF   63
0A90:  MOVLW  27
0A92:  MOVWF  62
0A94:  MOVLW  10
0A96:  MOVWF  61
0A98:  CLRF   65
0A9A:  CLRF   6F
0A9C:  CLRF   71
0A9E:  CLRF   70
0AA0:  MOVF   FC1,W
0AA2:  ANDLW  C0
0AA4:  IORLW  0F
0AA6:  MOVWF  FC1
0AA8:  MOVLW  07
0AAA:  MOVWF  FB4
.................... {
.................... 
....................    setup_adc_ports(NO_ANALOGS);
0AAC:  MOVF   FC1,W
0AAE:  ANDLW  C0
0AB0:  IORLW  0F
0AB2:  MOVWF  FC1
....................    
....................    modbus_init();
0AB4:  BRA    0436
....................    lcd_init();
0AB6:  BRA    0542
....................    delay_ms(100);
0AB8:  MOVLW  64
0ABA:  MOVWF  x80
0ABC:  RCALL  0442
....................    
....................    lcd_gotoxy(1,1);
0ABE:  MOVLW  01
0AC0:  MOVWF  x80
0AC2:  MOVWF  x81
0AC4:  RCALL  0594
....................    printf(lcd_putc,"System Started!");
0AC6:  MOVLW  FE
0AC8:  MOVWF  FF6
0ACA:  MOVLW  03
0ACC:  MOVWF  FF7
0ACE:  BRA    061C
.................... 
....................    
....................  while(TRUE){
.................... 
....................    //unsigned int16 reg_array[2] = {1, 22};
....................    //write_multiple_reg(1,2,reg_array);
....................    
....................    write_reg(1,d);
0AD0:  CLRF   75
0AD2:  MOVLW  01
0AD4:  MOVWF  74
0AD6:  CLRF   77
0AD8:  MOVFF  6F,76
0ADC:  BRA    0810
....................    read_all_holding(0,3);
0ADE:  CLRF   75
0AE0:  CLRF   74
0AE2:  CLRF   77
0AE4:  MOVLW  03
0AE6:  MOVWF  76
0AE8:  BRA    0902
....................    
....................    int c=1;
0AEA:  MOVLW  01
0AEC:  MOVWF  72
....................    for(int i=0; i<3;i++){ //lcd print
0AEE:  CLRF   73
0AF0:  MOVF   73,W
0AF2:  SUBLW  02
0AF4:  BNC   0B3A
....................       lcd_gotoxy(1,c+1);
0AF6:  MOVLW  01
0AF8:  ADDWF  72,W
0AFA:  MOVWF  74
0AFC:  MOVLW  01
0AFE:  MOVWF  x80
0B00:  MOVFF  74,81
0B04:  RCALL  0594
....................       printf(lcd_putc,"%lu      ",read_reg[i]);
0B06:  BCF    FD8.0
0B08:  RLCF   73,W
0B0A:  CLRF   03
0B0C:  ADDLW  69
0B0E:  MOVWF  FE9
0B10:  MOVLW  00
0B12:  ADDWFC 03,W
0B14:  MOVWF  FEA
0B16:  MOVFF  FEC,77
0B1A:  MOVF   FED,F
0B1C:  MOVFF  FEF,76
0B20:  MOVLW  10
0B22:  MOVWF  FE9
0B24:  BRA    0978
0B26:  MOVLW  11
0B28:  MOVWF  FF6
0B2A:  MOVLW  04
0B2C:  MOVWF  FF7
0B2E:  MOVLW  06
0B30:  MOVWF  76
0B32:  BRA    0A34
....................       c++;
0B34:  INCF   72,F
0B36:  INCF   73,F
0B38:  BRA    0AF0
....................    }
....................    
....................    if(read_reg[0]==1){ //if adress-reg 0 is 1 LED on
0B3A:  DECFSZ 69,W
0B3C:  BRA    0B46
0B3E:  MOVF   6A,F
0B40:  BNZ   0B46
....................       output_high(LED);
0B42:  BCF    F94.4
0B44:  BSF    F8B.4
....................    }
....................    
....................    if(read_reg[0]==0){ //if adress-reg 0 is 0 LED off
0B46:  MOVF   69,F
0B48:  BNZ   0B52
0B4A:  MOVF   6A,F
0B4C:  BNZ   0B52
....................       output_low(LED);
0B4E:  BCF    F94.4
0B50:  BCF    F8B.4
....................    }
....................    
....................    d++;
0B52:  INCF   6F,F
....................    delay_ms(100);
0B54:  MOVLW  64
0B56:  MOVWF  x80
0B58:  RCALL  0442
0B5A:  BRA    0AD0
....................    
....................    
....................  }
.................... }
.................... 
0B5C:  SLEEP 

Configuration Fuses:
   Word  1: C800   INTRC_IO FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
